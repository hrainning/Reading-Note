# ADT

## vector

特点：静态的，区间一开始就是划分好的，在物理上是连续的存储空间，可以根据秩直接确定物理位置

定义：数组的抽象与泛化，是一种线性序列

构造函数/实现：new一个数组，或是用copyfrom复制已有的数组 | vector

保护接口：

- copyfrom：复制 - new一个二倍size的数组[避免后期不必要的扩容]，后循环填入
- expend：扩容 - 成倍的扩充capacity，循环填入，使用加倍的方式扩容的时间成本更低，递增式空间成本低
- shrink：缩容 - 当填装因子小于1/4，成倍的缩小capacity

对外接口：

- size
- insert
- put
- find
- search
- sort
- disordered
- []
- remove
- delete
- duplicate
- uniquify

## List

定义：以节点作为基本元素，使用前驱和后继来实现逻辑上的线性序列。

特点：可以双向访问

初始化：双向链表，定义头尾俩哨兵以及size为0

接口：与vector差不多，但是实现有区别

## Stack

定义：只能通过top端进行访问

特点：LIFO

实现：继承vector

接口：

- push
- top
- empty
- size
- pop

应用场景：

1. 逆序输出：短除法进制转换
2. 递归嵌套：括号匹配
3. 延迟缓冲：中缀表达式[常用的] - 算术表达式求值 - 数栈+符号栈
4. 栈式计算：RPN逆波兰表达式计算[后缀] - 算术表达式求值 - 遇到符号从栈中取数计算

数学计算：

1. [栈混洗问题](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083694
   )，栈种类的数目，结果为卡塔兰数，(2n!)/((n+1)!*n!)

## queue

定义：尾部插入，头部输出的线性序列

实现：继承list，额外实现enqueue，dequeue等

特点：FIFO

接口：

- rear
- front
- enqueue
- dequeue
- empty
- size

## 树

定义：以层次结构来组织数据项

特点：非线性结构，但具有线性结构的特征，同时集合vector的search快，以及list的remove和insert快的优点。连通性，无环性

有序树：兄弟之间有编号，可以表现优先级

边的数量：等于节点数-1，或者是度数

路径长度：可用边的数量/点的数量，用边更方便

高度：空树高度为-1

序列表示法：父节点表示法、孩子节点表示法、父亲孩子表现法、长子兄弟表示法

接口：

- root
- parent
- firstchild
- nextsibling
- insert
- remover
- traverse

## 二叉树

定义：只有左右两个孩子

特点：可表示任何树，是基于长子兄弟表示法衍生的，涨宽速度更快

深度：logn向上取整

数量：每层最大数目是2的深度次方，点的数量最大为底层的两倍

节点模板类：BinNode - 带有一些额外的指标

节点的接口：

- insertAsLC
- insertAsRC
- succ
- travLevel
- travPre
- travIn
- travPost

BinTree接口：

protected：

- updateHeight
- updateHeightAbove

public:

- size
- empty
- root

树的重构：中序 + 【前序 | 后序】或者 真二叉 + 前序 + 后序

## Graph

定义：一堆边以及节点的集合

类别：有向图、无向图、有环图、无环图

欧拉环路：覆盖所有有向边且恰好一次的环路

哈密尔顿环路：每个节点只经过一次的简单环路

简单：不重复

实现：邻接矩阵、关联矩阵

点的结构：数据、发现/访问时间、父亲、状态、优先级、构造函数

边的结构：数据、权重、类型，构造函数

邻接矩阵评价：实现简单、运用广泛、使用效率高、良好的扩展性，空间性能不得行

## 二叉搜索树BST

定义：一组数据项构成的集合，每个数据项都实现为词条形式，每个词条对应于关键码

特点：满足顺序性，所有子树，左小右大，中序遍历是单调的，微观局部顺序性，全局单调性

优点：有序性使得查找插入等动作更为快速，但是高度不能达到最低，只有完全二叉树才能满足，但是完全满足代价过高，因此需要适度平衡

规范：

protected：

- _hot
- connect34
- rotateAt

public[最为重要的功能]:

- search
- insert
- remove：先与后继交换，再删除

元素相同树的种类：卡特兰数n个，平均树高根号n

记忆技巧：左孩子总小于父与父右，右孩子总是大于父与父左

## 平衡二叉搜索树AVL

定义：通过等价变换来达到让二叉搜索树达到适当平衡

平衡标准：平衡因子[左-右高度]绝对值不超过1 

平衡的技巧：

特点：高度不超过logn，节点数目下限为s(h)=fib(h+3)-1个

插入操作：复杂度logn，改正局部错误的那一个孩子即可，方向一致使用单旋，中间那个成为新节点，之字形使用双旋，最后一个成为新节点，调整一次全局平衡，因为高度保持不变

删除操作：复杂度常数1，方向一致使用单旋，但是由于分支高度改变，调整旋转可能需要logn次，之字形使用双旋转，最后一个成为新的节点，效果是先变成方向一致，而后再旋

旋转实现：使用3+4重构法，四个子树，三个父节点，一步到位组装而无需到处排

失衡情况：插入时所有祖先可能都会失衡，删除时至多只会失衡最近的一个祖先

评价：优 - 保证了各种操作复制度的底线，能在n的空间复杂度中让动态与静态操作insert、remove、search都达到最坏logn。 缺 - 需要额外改造元素结构添加平衡因子，且实际复杂度与理论有差距，删除操作导致的全树拓扑结构变化量可达logn的复杂度，对于平衡显得过于苛刻，平衡代价过高。

## 红黑树RBT

插入操作：常数1

删除操作：常数1

## 伸展树

定义：不断将刚被访问到的节点移动到根节点位置

特点：没有静态动作，search变成动态的，最坏会缩短一半

原理：利用局部性，刚访问到的数据附近会很快再访问，而根是最快被访问的

实现1：利用单旋，自下而上逐层上移，存在最坏情况导致效率不高

实现2：利用两次旋转，上升两层，与avl的不同，avl双旋相等于两次单，但这种每次都对三个中最上边的那个进行旋转，能让高度慢慢变小，转只用于同方向的三个点，之字形可以先单旋一下

评价：优 - 1、实现更为简单，因为不用记录高度和平衡因子，且复杂度也与avl相当。2、局部性强，命中效率更好。缺 - 无法杜绝单词最坏情况的出现，因此不适用于对单词操作效率敏感的场合

## B - 树

特点：物理上不满足二叉搜索树，但逻辑上却与BST相当

设计动机：在存储系统中使用，能充分利用外存的批量访问，能实现更少、更高效的I/O，与解决不同存储级别上的差异

定义：任何b树都有阶次的指标，n阶对应n路，所有的外部节点和叶子节点深度一致

阶次：m路平衡搜索树，分支上限m，下限m/2，根节点有特权可以只有一个关键码

结构：是一种存放一组具有关键码的词条的一种数据结构，每个节点可以有很多分叉，底层节点深度一致，较于寻常二叉查找树更宽更矮。是一种平衡的多路搜索树。引用和关键码间隔分布，数量差为1。

超级节点：由多代二叉搜索树组成，可以用线性序列实现，节点size大致为一次io对换的页面大小，一般为几百个

高度：下界logn，渐进时间复杂度即logn，单常数优化更佳，m为256时，高度最差为最佳平衡二叉树1/7，最好为1/8，b树的高度变化幅度有限

节点数：内部m外部就是n+1，有n中成功的可能就有n+1种失败的可能

道法自然：通过改变操作方向，来达到最优

接口：

private：

- solveoverflow：解决上溢 - 分裂处理 - 选取中位值上移一层，而后两边分别作为其左右引用，若根节点上溢，则中位值成为一个新的根节点，高度+1，多次分裂的概率很低
- solveunderflow：解决下溢 - 合并处理 -  1、旋转法：先左右看，兄弟是否数量高于下界，若有则先从父节点中借来一个关键码，而父节点则向兄弟借回一个关键码来。2、合并法：若左右兄弟恰好为下界，无法借出，则恰好可以用父节点下移来粘合其中一个兄弟，合并为一整个超级节点。只有合并操作才会导致高度下降。

public：

- search：只载入必要的节点，减少io，先在超级节点内部查找，若无则根据引用载入新的超级节点，统计表明对于大致几百的数目，二分效率没有顺序快。
- insert：直接深入到底层叶子，插入序列中，若上溢则分裂
- remove：删除叶子可以直接删除，非叶子则扫描右的一直左得到后继，然后直接删除，若下溢则分裂

## 红黑树RB-TREE

目的：每次查找与自平衡都能快速的完成

存在的意义：传统数据结构若要实现持久性结构，既访问历史版本，空间代价过高[n*h]。使用关联性的方法能更好的实现，通过计算机几何能实现h *logN。用红黑树可以使得每次的拓扑结构变换复杂度都能控制在O(1)，使得不同版本间的差距更小，avl只能保证插入时如此，删除时不可。

