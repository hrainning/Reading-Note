# ADT

## vector

特点：静态的，区间一开始就是划分好的，在物理上是连续的存储空间，可以根据秩直接确定物理位置

定义：数组的抽象与泛化，是一种线性序列

构造函数/实现：new一个数组，或是用copyfrom复制已有的数组 | vector

保护接口：

- copyfrom：复制 - new一个二倍size的数组[避免后期不必要的扩容]，后循环填入
- expend：扩容 - 成倍的扩充capacity，循环填入，使用加倍的方式扩容的时间成本更低，递增式空间成本低
- shrink：缩容 - 当填装因子小于1/4，成倍的缩小capacity

对外接口：

- size
- insert
- put
- find
- search
- sort
- disordered
- []
- remove
- delete
- duplicate
- uniquify

## List

定义：以节点作为基本元素，使用前驱和后继来实现逻辑上的线性序列。

特点：可以双向访问

初始化：双向链表，定义头尾俩哨兵以及size为0

接口：与vector差不多，但是实现有区别

## Stack

定义：只能通过top端进行访问

特点：LIFO

实现：继承vector

接口：

- push
- top
- empty
- size
- pop

应用场景：

1. 逆序输出：短除法进制转换
2. 递归嵌套：括号匹配
3. 延迟缓冲：中缀表达式[常用的] - 算术表达式求值 - 数栈+符号栈
4. 栈式计算：RPN逆波兰表达式计算[后缀] - 算术表达式求值 - 遇到符号从栈中取数计算

数学计算：

1. [栈混洗问题](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083694
   )，栈种类的数目，结果为卡塔兰数，(2n!)/((n+1)!*n!)

## queue

定义：尾部插入，头部输出的线性序列

实现：继承list，额外实现enqueue，dequeue等

特点：FIFO

接口：

- rear
- front
- enqueue
- dequeue
- empty
- size

## 树

定义：以层次结构来组织数据项

特点：非线性结构，但具有线性结构的特征，同时集合vector的search快，以及list的remove和insert快的优点。连通性，无环性

有序树：兄弟之间有编号，可以表现优先级

边的数量：等于节点数-1，或者是度数

路径长度：可用边的数量/点的数量，用边更方便

高度：空树高度为-1

序列表示法：父节点表示法、孩子节点表示法、父亲孩子表现法、长子兄弟表示法

接口：

- root
- parent
- firstchild
- nextsibling
- insert
- remover
- traverse

## 二叉树

定义：只有左右两个孩子

特点：可表示任何树，是基于长子兄弟表示法衍生的，涨宽速度更快

深度：logn向上取整

数量：每层最大数目是2的深度次方，点的数量最大为底层的两倍

节点模板类：BinNode - 带有一些额外的指标

节点的接口：

- insertAsLC
- insertAsRC
- succ
- travLevel
- travPre
- travIn
- travPost

BinTree接口：

protected：

- updateHeight
- updateHeightAbove

public:

- size
- empty
- root

树的重构：中序 + 【前序 | 后序】或者 真二叉 + 前序 + 后序

## Graph

定义：一堆边以及节点的集合

类别：有向图、无向图、有环图、无环图

欧拉环路：覆盖所有有向边且恰好一次的环路

哈密尔顿环路：每个节点只经过一次的简单环路

简单：不重复

实现：邻接矩阵、关联矩阵

点的结构：数据、发现/访问时间、父亲、状态、优先级、构造函数

边的结构：数据、权重、类型，构造函数

邻接矩阵评价：实现简单、运用广泛、使用效率高、良好的扩展性，空间性能不得行

## 二叉搜索树BST

定义：一组数据项构成的集合，每个数据项都实现为词条形式，每个词条对应于关键码

特点：满足顺序性，所有子树，左小右大，中序遍历是单调的，微观局部顺序性，全局单调性

优点：有序性使得查找插入等动作更为快速，但是高度不能达到最低，只有完全二叉树才能满足，但是完全满足代价过高，因此需要适度平衡

数量：外部节点数量  = 内部节点+1

规范：

protected：

- _hot
- connect34
- rotateAt

public[最为重要的功能]:

- search
- insert
- remove：先与后继交换，再删除

元素相同树的种类：卡特兰数n个，平均树高根号n

记忆技巧：左孩子总小于父与父右，右孩子总是大于父与父左

## 平衡二叉搜索树AVL

定义：通过等价变换来达到让二叉搜索树达到适当平衡

平衡标准：平衡因子[左-右高度]绝对值不超过1 

平衡的技巧：

特点：高度不超过logn，节点数目下限为s(h)=fib(h+3)-1个

插入操作：复杂度logn，改正局部错误的那一个孩子即可，方向一致使用单旋，中间那个成为新节点，之字形使用双旋，最后一个成为新节点，调整一次全局平衡，因为高度保持不变

删除操作：复杂度常数1，方向一致使用单旋，但是由于分支高度改变，调整旋转可能需要logn次，之字形使用双旋转，最后一个成为新的节点，效果是先变成方向一致，而后再旋

旋转实现：使用3+4重构法，四个子树，三个父节点，一步到位组装而无需到处排

失衡情况：插入时所有祖先可能都会失衡，删除时至多只会失衡最近的一个祖先

评价：优 - 保证了各种操作复制度的底线，能在n的空间复杂度中让动态与静态操作insert、remove、search都达到最坏logn。 缺 - 需要额外改造元素结构添加平衡因子，且实际复杂度与理论有差距，删除操作导致的全树拓扑结构变化量可达logn的复杂度，对于平衡显得过于苛刻，平衡代价过高。

## 伸展树

定义：不断将刚被访问到的节点移动到根节点位置

特点：没有静态动作，search变成动态的，最坏会缩短一半

原理：利用局部性，刚访问到的数据附近会很快再访问，而根是最快被访问的

实现1：利用单旋，自下而上逐层上移，存在最坏情况导致效率不高

实现2：利用两次旋转，上升两层，与avl的不同，avl双旋相等于两次单，但这种每次都对三个中最上边的那个进行旋转，能让高度慢慢变小，转只用于同方向的三个点，之字形可以先单旋一下

评价：优 - 1、实现更为简单，因为不用记录高度和平衡因子，且复杂度也与avl相当。2、局部性强，命中效率更好。缺 - 无法杜绝单词最坏情况的出现，因此不适用于对单词操作效率敏感的场合

## B - 树

特点：物理上不满足二叉搜索树，但逻辑上却与BST相当

设计动机：在存储系统中使用，能充分利用外存的批量访问，能实现更少、更高效的I/O，与解决不同存储级别上的差异

定义：任何b树都有阶次的指标，n阶对应n路，所有的外部节点和叶子节点深度一致

阶次：m路平衡搜索树，分支上限m，下限m/2，根节点有特权可以只有一个关键码

结构：是一种存放一组具有关键码的词条的一种数据结构，每个节点可以有很多分叉，底层节点深度一致，较于寻常二叉查找树更宽更矮。是一种平衡的多路搜索树。引用和关键码间隔分布，数量差为1。

超级节点：由多代二叉搜索树组成，可以用线性序列实现，节点size大致为一次io对换的页面大小，一般为几百个

高度：下界logn，渐进时间复杂度即logn，单常数优化更佳，m为256时，高度最差为最佳平衡二叉树1/7，最好为1/8，b树的高度变化幅度有限

节点数：内部m外部就是n+1，有n中成功的可能就有n+1种失败的可能

道法自然：通过改变操作方向，来达到最优

接口：

private：

- solveoverflow：解决上溢 - 分裂处理 - 选取中位值上移一层，而后两边分别作为其左右引用，若根节点上溢，则中位值成为一个新的根节点，高度+1，多次分裂的概率很低
- solveunderflow：解决下溢 - 合并处理 -  1、旋转法：先左右看，兄弟是否数量高于下界，若有则先从父节点中借来一个关键码，而父节点则向兄弟借回一个关键码来。2、合并法：若左右兄弟恰好为下界，无法借出，则恰好可以用父节点下移来粘合其中一个兄弟，合并为一整个超级节点。只有合并操作才会导致高度下降。

public：

- search：只载入必要的节点，减少io，先在超级节点内部查找，若无则根据引用载入新的超级节点，统计表明对于大致几百的数目，二分效率没有顺序快。
- insert：直接深入到底层叶子，插入序列中，若上溢则分裂
- remove：删除叶子可以直接删除，非叶子则扫描右的一直左得到后继，然后直接删除，若下溢则分裂

## 红黑树RB-TREE

目的：每次查找与自平衡都能快速的完成

本质：也是一种bst，提升变换后是一个4阶的b树，分支上下界为2，4

存在的意义：传统数据结构若要实现持久性结构，既访问历史版本，空间代价过高[n*h]。使用关联性的方法能更好的实现，通过计算机几何能实现h *logN。用红黑树可以使得每次的**拓扑结构变换**复杂度都能控制在O(1)，使得不同版本间的差距更小，每次只需要记录一次的变换，avl只能保证插入时如此，删除时不可。

提升变换：红色节点移动到父节点的左右两侧

规则定义：

- 【统一增加外部节点null，成为真二叉树】
- 树根必定为黑
- 外部都是黑色
- 控制深度[黑]：红节点只能有黑色孩子 =》 红节点孩子父亲都是黑 =》 红色不相邻
- 控制平衡性：外部节点到根，黑数目相等

接口：

protected：

- solveDoubleRed：双红问题，从b树的角度来看，先提升变换，1、红黑组合为超级节点为3个节点的时候，错误的原因在于超级节点，黑色关键码不在中间，因此只需要调换中间红和黑反转就可。2、4个关键码时，出现上溢，存在三个红，黑转红，红转黑，新入的不变。可能需要递归向上继续变换颜色。不改变拓扑结构，只换颜色就可。
- solveDoubleBlack：删除的挑战，与b树相同，1、优先查看是否能够使用旋转法，需要改变拓扑结构，新父继承原色。2、考虑使用合并法，父为红的时候只需要改变颜色，父为黑先旋转并交换兄父颜色，产生父红情况再删除。局部解决则全局解决，可能需要改局部。
- updateHeight

public：

- 静态search：与寻常bst相同
- insert：借助b树来理解，先染成红色，照着bst方法插入，处理双红问题，而只会进行常数次染色操作，avl也可常数次，对于持久化结构来说，作用相当。
- remove：先用bst常规删除，先替换后继再删除，而后处理各种问题。1、与后继中有一个为红，则替换后直接染黑即可；2、交换两者都为黑时；3、交换两者都为红时。旋转次数[拓扑结构]较avl的logn更快更少，至多logn次重染色，一次重构单旋，对于持久性结构更关键。

## 词典

散列：组织数据的一种思想，寻值访问

访问数据的方式：寻秩-vector | 寻位置 - list | 寻关键码 - bst | 寻值访问 - hash

hash原理：用桶直接或间接存放词条，通过词条的key与散列函数直接确定散列表的入口找到对应桶。

散列函数本质：将一个大范围取值的值，映射到一个更小的取值阈

装填因子：实际所用占空间比

散列任务：1、散列表；2、散列函数。降低冲突概率

函数选取：1、取余法 - mod 素数最佳；2、 MAD法 -  * + mod三次计算；3、数字分析法 -  抽几位当地址；4、平方取中 - 先平方再抽几位来当地址；5、折叠法 - 分割再相加；6、异或法 - 分割再异或；7、随机数法 - 用rand来实现；8、多项式法 - 每一项都拿来计算；

函数选取评价：0为不动点，且均匀性不佳，相邻的继续相邻，MAD在均匀性上更好。

散列函数的优劣：确定性、快速性、满射、均匀。分布越随机、越无规律越好。

冲突解决：1、多槽位法，一开始每个桶都设置多个槽；2、独立链法，槽用list来代替；3、开放地址法，将空闲的桶开放给别人，可用线性试探 / 平方试探 / 双向平方试探 的方法逐步探查

各方法优劣：1、多槽位，一开始就设置多余的空间，浪费空间；2、动态申请消耗大，空间不连续，无法使用系统缓存；3、无需附加空间，可以充分利用系统缓存，但是增加后续元素冲突的风险

开放地址探测策略评估：线性 - 后续可能导致多次连续冲突；平方 - 破坏数据访问的局部性，可能会导致有空找不到的情况[装填因子>m/2]，但是能解决数据聚集冲突问题；双向 - 在表长为4*k+3的size能使用整个表

开放地址法删除修正：用**懒惰清除**的方法，防止后方不被跳过，将要删除的桶打上标记即可

## 优先级队列

定义：元素根据优先级进行访问，栈和普通的队列是优先队列的特殊情况

应用：哈夫曼编码[每次选择俩最小数合并为一个树]；扫描线策略算法

接口：

- insert
- getMax
- delMax

底层结构：1、使用vector / list除了insert，其他代价都高；2、有序vector / list，insert代价比较高；3、使用bbst，都可logn，但功能过于强大；4、使用完全二叉堆，只实现了偏序，成本低又快，也是logn，很好。

## 完全二叉堆

实现：使用数组或vector

设计动机：实现优先队列，需要一种简单、高效的数据结构，因此引入。

定义：逻辑上等价于完全二叉树，物理上用vector来实现

特点：子为两倍 或 两倍+1.

接口：

protected：

- percolateDown：下滤，delMax用来调整的，父不断和孩子中最大的交换下移。
- percolateUp：上滤，insert用来调整的，若父小，则不断与父互换
- heapify：从后往前[n/2]，对所有的内部节点都进行一次下滤，每次合成一个子堆。只需要O(n)，越下边交换次数越少。

public：

- PQ_complHeap：用copyform来构造，先复制到数组中，然后调用heapify开始调整为堆
- insert：先丢入末尾，调用precolateUp调整
- getMax：直接获取堆顶
- delMax：摘除第一个，末节点代替。用percolateDown调整。logn

堆序性：

- 大顶堆[默]：任何节点，值不超过父亲
- 小顶堆：父节点小于任何孩子

应用：优化选择排序中，每次选择最大的步骤，可以将其复杂度优化为nlogn。还能用做优先队列的底层

## 左式堆

实现：继承优先队列以及二叉树实现

引入动机：为了快速合并堆。直接使用heapify可以线性o(n)，但是没有使用俩堆本身的偏序性信息。构建左式堆，可以在log(n)的情况下合并堆。

结构：左孩子的npl值不小于右孩子的npl值，根的右侧链长度最大为logn

合并结果：合并只涉及右侧，节点多分布于左侧，完全二叉结构丢失，堆结构依旧保留

npl值：null path length每个节点引入npl值，代表距离null外部节点最短的距离值，也是以其为根节点的极大满树的高度。

右侧链：x的右侧链，既从x除法，一直沿着右分支前进的路径，右侧链的终点必定为全堆中最浅的外部节点。

接口：

public:

- insert：可以视作仅有一个节点的左式堆之合并
- getMax
- delMax：删除根之后，再对左右俩进行合并

外部：

- merge：以较大的a作为b[swap]的父，a的右孩子递归的与b合并，每次合并，若右子树npl>左子树的npl则左右替换，最终更新根的npl。由于是围绕右侧链进行的合并，因此复杂度为logn

## 串

定义：由来自字母表的字符构成的有限线性序列

特点：字符有限，长度很长

接口：

- length
- charAt
- substr
- prefix
- suffix
- concat
- equal
- indexof：子串与某个串是否相等

串匹配[子串匹配]问题：

- 是否出现
- 在哪儿第一次出现
- 出现了几次
- 各自出现在哪儿

串匹配方法：

- 蛮力法：最好O(m)，最坏O(n*m)，字母表越小约容易出现坏情况。m越大没找着的后果越高。
- KMP算法：最坏不过O(2n)，集合越字母越少越有用。但是依旧很有用。效果是去除了很多次失败比对。

- BM_bc算法：坏字符策略，最好情况n/m[不断失配]，字母表越大越有用，因为更容易失配。 最差情况会变得和蛮力相同。
- MB_GS算法：好后缀策略，bc的移动优化策略。构造移动表除非蛮力，否则有点不好实现。
- Karp-Rabin算法：把串转换为数，每次hash都是常数次，且前后两次的次数相关，取余数再乘上再+新的就能得到新的数。冲突的次数也不会很多。