## 排序算法

##### [冒泡排序](https://www.bilibili.com/video/BV1db411L71m?p=13)

思路：扫描交换，依次比较相邻元素，若有必要则交换，大的不断后移

复杂度：n²

类别：减治

## 查找算法

#### 无需序列

##### 遍历查找

#### 有序序列

##### [二分查找](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083609)

思路：每次选中中间的元素用以判断查找元素处于哪一个区间中，成倍的缩小查找范围

复杂度：1.5logn

类别：减治

##### [Fibonacci查找](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083617)

思路：

复杂度：

类别

## 问题

##### [数组倒置](https://www.bilibili.com/video/BV1db411L71m?p=20)

思路：前后两个指针不断交换靠近，直到相遇

##### [最大俩值](https://www.bilibili.com/video/BV1db411L71m?p=23&t=519)

思路1：设置两个值分别记录第一大和第二大，遍历先跟第二比再跟第一比

**思路2**：分治，两部分各自保留第一大跟第二大，合并的时候比较保留大的

##### [斐波那契数列](https://www.bilibili.com/video/BV1db411L71m?p=27)(fib)

思路1：自顶向下递归实现

**思路2**：自底而上迭代的方式实现，用表记忆计算过的实例 或 动态规划

##### [计算最长公共子序列](https://www.bilibili.com/video/BV1db411L71m?p=32)(LCS)

思路1：减治法+分治法，从后往前递归寻找，每次减少两个或其中一个字符串的字符，遍历所有的可能

**思路2**：动态规划法，从前往后，绘制一张表格记录，透过左侧与对角值计算所有的可能子序列长度，字符相等时对角+1，不等时则为左侧值。

##### [序列唯一化](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083598)

思路1：划分前唯一和后子序列，每次循环不断扫描唯一序列对比，不存在既加入，最终子序列为空

**思路2**：先排序，后前后俩元素对比

**思路3**：数值型序列，设置一个bit数组记录是否存在，若已经标记过的则删除。

## 正确性说明

- 单调性：问题的规模不断减少
- 不变性：每次都能找到一个子问题的答案

  