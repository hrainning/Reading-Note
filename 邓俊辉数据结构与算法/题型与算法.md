## 排序算法

##### [冒泡排序](https://www.bilibili.com/video/BV1db411L71m?p=13)

思路：扫描交换，依次比较相邻元素，若有必要则交换，大的不断后移

复杂度：n²

类别：减治

稳定性：可

改进1：设置一个标志记录是否排序过，以便提前结束

改进2：记录最后一次排序的位置，后方都是已经排序好的，可以更快的跳过

##### [归并排序](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083636)

思路：先将向量或数组分解为最小单位，而后不断递归合并为有序

复杂度：nlogn

类别：分治

##### [选择排序](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083660)

思路：每次选择出最大的一个，最后全部排在一起，选择排序较于冒泡一次交换到位。

类别：减治

复杂度：n²

稳定性：可

优化：用堆来实现选择最大的元素，每次只用logn，复杂度可以优化为nlogn，此法也叫**堆排序**

##### [插入排序](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083666)

思路：分为有序无序两个部分，每次从无序中拿到一个新的数字都按照顺序插入到有序序列中，与选择排序的区别在于无序部分和有序部分值大小没有关联，而插入排序有序必大于无序

类别：减治

复杂度：n²

特色：输入敏感度(逆序对数量)对算法执行时间有很大的影响

敏感性:对逆序对带有敏感性,逆序对越少越快.改变的次数正比与逆序对的数量

##### 桶排序

思路：先设置k个桶，把元素划分到不同的同种，再在桶内排序，最终合成一个大的有序序列

复杂度：O(n)

##### 计数排序

思路：本质上是最大数量的桶的排序，计算每个桶[元素]的数量，再根据数量写出最终排序的序列

复杂度：O(n)

##### [快速排序](https://next.xuetangx.com/learn/THU08091002048/THU08091002048/4215520/video/6084111)

思路：先把轴点逐步交换到其该在的位置上，使其整出左小右大，然后分别对两边再进行快速排序。

稳定性：不稳定

类型：分治

复杂度：1.39nlogn，最好nlogn，最坏n²

取轴优化：随机选取法、三者取中法

轴点移动优化：区间多分出一个未划分的，设置less和big的俩指针，未划分起点为u，然后不断后移，出现小于的就将其与big起点交换送给less，big+1，否则直接u++就可。

##### [希尔排序](https://next.xuetangx.com/learn/THU08091002048/THU08091002048/4215520/video/6084138)

思路:将序列看作为一个矩阵,每次对每列进行排序,而后每次又降低矩阵宽度,如此反复,直到只剩1列.既每次排序的小序列size慢慢变大. 每次排序的算法的选择输入敏感的算法,如插入排序.

优秀的缘由:逆序对不断减少

复杂度:最坏n²

特点:g>h,希尔中g-ordered在h-ordered中也依旧存在.

## 选择问题

##### 选取中位数 / 第k位

思路1:先排序,再选出第k个

思路2:先组织为一个堆[O(n)],del到第k个(klogn) 

思路3:先组织k大小的堆[O(k)],然后用剩下的元素对其做插入,再删除max[(2*(n-k) *logk)],最后堆顶剩下的就是第k大的.

思路4:组织一个k大的大顶堆,剩下的组织为小顶堆,然后顶点若小>大顶堆的则互换,直到最后不变,小顶堆的顶就是了.

思路5:快速选择法,每次都安排上一个轴点到一个位置,不断缩小范围.

**思路6**:linearSelect,当够小的可用上边的算法走,否则先按Q划分多个序列,每个序列各自排序选出中位数,再将所有的中位数取出再求中位数,然后将全序列划分为小于\等于\大于三部分,根据三部分递归的再次查找.在理论上可达到线性复杂度,但系数蛮大.

## 查找算法

#### 无需序列

##### 遍历查找

#### 有序序列[轴点]

##### [二分查找](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083609)

思路：每次选中中间的元素用以判断查找元素处于哪一个区间中，成倍的缩小查找范围

复杂度：1.5logn

类别：减治

##### [Fibonacci查找](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083617)

思路：每次根据斐波那契切分点进行判别，近似黄金分点，并不断的缩小范围，目的是考虑到左右比较次数不均衡，为了让其更加均衡。

复杂度：1.44logn

类别：减治

##### [插值查找](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083626)

思路：若数组中的元素呈现均匀分布，则可以根据值来插值计算来大致判断所处位置，并将mid设置在猜测点上,若mid不在范围内则是查找失败，区间每次缩小至√n

复杂度：o(loglogn)

类别：减治

## 问题

##### [数组倒置](https://www.bilibili.com/video/BV1db411L71m?p=20)

思路：前后两个指针不断交换靠近，直到相遇

##### [最大俩值](https://www.bilibili.com/video/BV1db411L71m?p=23&t=519)

思路1：设置两个值分别记录第一大和第二大，遍历先跟第二比再跟第一比

**思路2**：分治，两部分各自保留第一大跟第二大，合并的时候比较保留大的

##### [斐波那契数列](https://www.bilibili.com/video/BV1db411L71m?p=27)(fib)

思路1：自顶向下递归实现

**思路2**：自底而上迭代的方式实现，用表记忆计算过的实例 或 动态规划

##### [计算最长公共子序列](https://www.bilibili.com/video/BV1db411L71m?p=32)(LCS)

思路1：减治法+分治法，从后往前递归寻找，每次减少两个或其中一个字符串的字符，遍历所有的可能

**思路2**：动态规划法，从前往后，绘制一张表格记录，透过左侧与对角值计算所有的可能子序列长度，字符相等时对角+1，不等时则为左侧值。

##### [串匹配-模式匹配](https://next.xuetangx.com/learn/THU08091002048/THU08091002048/4215520/video/6084057)

思路1：暴力破解法，遍历整个字符串，逐个进行比对。

思路2：KMP算法，匹配前先根据匹配串计算一个查询表，当出现失败，根据查询表来判断应该移动多少位，移完之后再继续比较。使得模式串滑动速度加快，跳过一些不必要的比对。[构造表的算法](https://next.xuetangx.com/learn/THU08091002048/THU08091002048/4215520/video/6084085)与对比时近似，采用递推方式，从前哨兵-1往后开始计算，当遇到相同的则+1，不同的则退回next继续计算。

**思路3**：BM_bc算法，模式串从后开始往前比较，当错误时，根据bm查询表，找到与之相同的，然后向后移动，让相同的放在一起。

思路4：BM_GS算法，bc的改进，移动时，会根据事先定义的位移表来让查询需要移动多长。造表用蛮力算法来实现。

**思路5**：Karp-Rabin算法，利用hash的思路，先将子串转换为数值，然后对每个子串进行hash转换，若hash值一致时才开始匹配比较。

##### [序列唯一化](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083598)

思路1：划分前唯一和后子序列，每次循环不断扫描唯一序列对比，不存在既加入，最终子序列为空

**思路2**：先排序，后前后俩元素对比

**思路3**：数值型序列，设置一个bit数组记录是否存在，若已经标记过的则删除。

##### [如何判断任意排序是否为栈混洗](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083695)

思路1：原栈中若存在相邻i、j、k，则栈混洗中必不可能出现k，i，j，这是充要条件。

**思路2**：反向贪心模拟栈混洗，看是否满足条件

##### [中缀表达式转化为后缀表达式](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083709)

思路1[手工]：1、用括号显示的表示优先级；2、运算符移到对应的右括号后；3、消除所有的括号

思路2[代码]：隐式模拟手工加括号的过程，运算符执行的时候添加符号

##### [二叉树的遍历](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083742)[非递归]

先序遍历1：用递归版本中的尾递归直接改写为迭代版本，用辅助栈实现

先序遍历2：先访问整个左链，再由下而上以同样方式访问右子树。先访问节点的左链，压入对应左链的右子树，再弹出栈中top的右子树转交控制权，重复操作

中序遍历：访问某个节点时，它的整个左子树都被访问过了，由下而上逐个访问左链。先把所有左链压入栈，弹出栈顶访问，控制权送给右子树，如此重复。

层序遍历：使用队列，输出时附带加入左右孩子，直到为空

迭代优点：递归需要通用性，要额外的空间与操作，递归的代价更高

##### [图的遍历](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083784)

广度优先遍历

深度优先遍历：有向图中backward回边可用代表一个回路。记录首次访问时间和访问结束时间，可以定义活跃期，有父子关系的活跃期有包含关系，而无关系的没关系。

##### [找超过一半的数](https://next.xuetangx.com/learn/THU08091002048/THU08091002048/4215520/video/6084126)

思路1:先遍历一遍,然后统计数目,选出极值就可判断

**思路2:**每次将第一个遇到的数作为候选者,逐步向后扫描,遇到相同+1遇到不同-1,最终返回剩下的那个

## 正确性说明

- 单调性：问题的规模不断减少
- 不变性：每次都能找到一个子问题的答案


## 算法的区别

1、思路；2、时间复杂度好坏平均；3、数据特点

## 问题解决思路

1、问题有啥

2、如何处理

3、为啥要这样处理

4、评价处理的效率