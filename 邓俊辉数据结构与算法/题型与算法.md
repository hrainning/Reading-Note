## 排序算法

##### [冒泡排序](https://www.bilibili.com/video/BV1db411L71m?p=13)

思路：扫描交换，依次比较相邻元素，若有必要则交换，大的不断后移

复杂度：n²

类别：减治

稳定性：可

改进1：设置一个标志记录是否排序过，以便提前结束

改进2：记录最后一次排序的位置，后方都是已经排序好的，可以更快的跳过

##### [归并排序](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083636)

思路：先将向量或数组分解为最小单位，而后不断递归合并为有序

复杂度：nlogn

类别：分治

##### [选择排序](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083660)

思路：每次选择出最大的一个，最后全部排在一起，选择排序较于冒泡一次交换到位。

类别：减治

复杂度：n²

稳定性：可

优化：用堆来实现选择最大的元素，每次只用logn，复杂度可以优化为nlogn

##### [插入排序](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083666)

思路：分为有序无序两个部分，每次从无序中拿到一个新的数字都按照顺序插入到有序序列中，与选择排序的区别在于无序部分和有序部分值大小没有关联，而插入排序有序必大于无序

类别：减治

复杂度：n²

特色：输入敏感度(逆序对数量)对算法执行时间有很大的影响

##### 桶排序

思路：先设置k个桶，把元素划分到不同的同种，再在桶内排序，最终合成一个大的有序序列

复杂度：O(n)

##### 计数排序

思路：本质上是最大数量的桶的排序，计算每个桶[元素]的数量，再根据数量写出最终排序的序列

复杂度：O(n)

## 查找算法

#### 无需序列

##### 遍历查找

#### 有序序列[轴点]

##### [二分查找](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083609)

思路：每次选中中间的元素用以判断查找元素处于哪一个区间中，成倍的缩小查找范围

复杂度：1.5logn

类别：减治

##### [Fibonacci查找](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083617)

思路：每次根据斐波那契切分点进行判别，近似黄金分点，并不断的缩小范围，目的是考虑到左右比较次数不均衡，为了让其更加均衡。

复杂度：1.44logn

类别：减治

##### [插值查找](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083626)

思路：若数组中的元素呈现均匀分布，则可以根据值来插值计算来大致判断所处位置，并将mid设置在猜测点上,若mid不在范围内则是查找失败，区间每次缩小至√n

复杂度：o(loglogn)

类别：减治

## 问题

##### [数组倒置](https://www.bilibili.com/video/BV1db411L71m?p=20)

思路：前后两个指针不断交换靠近，直到相遇

##### [最大俩值](https://www.bilibili.com/video/BV1db411L71m?p=23&t=519)

思路1：设置两个值分别记录第一大和第二大，遍历先跟第二比再跟第一比

**思路2**：分治，两部分各自保留第一大跟第二大，合并的时候比较保留大的

##### [斐波那契数列](https://www.bilibili.com/video/BV1db411L71m?p=27)(fib)

思路1：自顶向下递归实现

**思路2**：自底而上迭代的方式实现，用表记忆计算过的实例 或 动态规划

##### [计算最长公共子序列](https://www.bilibili.com/video/BV1db411L71m?p=32)(LCS)

思路1：减治法+分治法，从后往前递归寻找，每次减少两个或其中一个字符串的字符，遍历所有的可能

**思路2**：动态规划法，从前往后，绘制一张表格记录，透过左侧与对角值计算所有的可能子序列长度，字符相等时对角+1，不等时则为左侧值。

##### [序列唯一化](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083598)

思路1：划分前唯一和后子序列，每次循环不断扫描唯一序列对比，不存在既加入，最终子序列为空

**思路2**：先排序，后前后俩元素对比

**思路3**：数值型序列，设置一个bit数组记录是否存在，若已经标记过的则删除。

##### [如何判断任意排序是否为栈混洗](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083695)

思路1：原栈中若存在相邻i、j、k，则栈混洗中必不可能出现k，i，j，这是充要条件。

**思路2**：反向贪心模拟栈混洗，看是否满足条件

##### [中缀表达式转化为后缀表达式](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083709)

思路1[手工]：1、用括号显示的表示优先级；2、运算符移到对应的右括号后；3、消除所有的括号

思路2[代码]：隐式模拟手工加括号的过程，运算符执行的时候添加符号

##### [二叉树的遍历](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083742)[非递归]

先序遍历1：用递归版本中的尾递归直接改写为迭代版本，用辅助栈实现

先序遍历2：先访问整个左链，再由下而上以同样方式访问右子树。先访问节点的左链，压入对应左链的右子树，再弹出栈中top的右子树转交控制权，重复操作

中序遍历：访问某个节点时，它的整个左子树都被访问过了，由下而上逐个访问左链。先把所有左链压入栈，弹出栈顶访问，控制权送给右子树，如此重复。

层序遍历：使用队列，输出时附带加入左右孩子，直到为空

迭代优点：递归需要通用性，要额外的空间与操作，递归的代价更高

##### [图的遍历](https://next.xuetangx.com/learn/THU08091000384/THU08091000384/4215507/video/6083784)

广度优先遍历

深度优先遍历：有向图中backward回边可用代表一个回路。记录首次访问时间和访问结束时间，可以定义活跃期，有父子关系的活跃期有包含关系，而无关系的没关系。

## 正确性说明

- 单调性：问题的规模不断减少
- 不变性：每次都能找到一个子问题的答案


## 算法的区别

1、思路；2、时间复杂度好坏平均；3、数据特点

## 问题解决思路

1、问题有啥

2、如何处理

3、为啥要这样处理

4、评价处理的效率