## 寄存器

汇编本质上通过对寄存器的操作来实现对CPU的操作。

寄存器可以分为通用寄存器、段寄存器和专用寄存器

## 通用寄存器

### 数据寄存器

① AX：累加器，运算时较多使用这个寄存器，有些指令规定必须使用它。
② BX：基址寄存器，除了存放数据，它经常用来存放一段内存的起始偏移地址。
③ CX：计数寄存器，除了存放数据，它经常用来存放重复操作的次数。
④ DX：数据寄存器，除了存放数据，它有时存放32位数据的高16位。

都可以拆分为两个8位寄存器使用，分别命名为AH，AL，BH，BL，CH，CL， DH，DL

32位80x86处理器的4个数据寄存器扩展为32位，更名为EAX，EBX，ECX，EDX，但仍然可以使用原有的16位和8位寄存器，且名称不变，如AX，BX，CX，DX，AH，AL等

### 地址寄存器

① SP：堆栈指针，这是一个专用的寄存器，存放堆栈栈顶的偏移地址。
② BP：基址指针，可以用来存放内存中数据的偏移地址。
③ SI：源变址寄存器，它经常用来存放内存中源数据区的偏移地址，所谓变址寄存器，是指在某些指令作用下它可以自动地递增或递减其中的值。
④ DI：目的变址寄存器，它经常用来存放内存中目的数据区的偏移地址，并在某些指令作用下可以自动地递增或递减其中的值。

32位80x86处理器的地址寄存器也扩展为32位，分别命名为ESP，EBP，ESI，EDI。

## 段寄存器

① CS：代码段寄存器，用来存放当前正在执行的程序段的段基址。
② SS：堆栈段寄存器，用来存放堆栈段的段基址。
③ DS：数据段寄存器，用来存放数据段的段基址。
④ ES：附加段寄存器，用来存放另一个数据段的段基址。

32位80x86处理器仍然使用16位的段寄存器，但是它们存储的内容发生了变化。此外，32位80x86处理器还增加了两个段寄存器FS和GS，它们的作用与ES类似。

## 专用寄存器

- IP：指令指针寄存器，存放即将执行指令的偏移地址。
- FLAGS：存放CPU的两类标志。

① OF：溢出标志。OF=l表示两个有符号数的运算结果超出了可以表示的范围，结果是错误的；OF=0 表示没有溢出，结果正确。进行无符号数运算时也会产生新的 OF 标志（CPU 不知道处理对象是否为有符号数），此时程序员可以不关心OF标志。
② DF：方向标志。DF=0时，每次执行字符串指令后，源或目的地址指针用加法自动修改地址；DF=l时用减法来修改地址。它用来控制地址的变化方向。
③ IF：中断允许标志。IF=l 表示允许处理器响应可屏蔽中断请求信号，称为开中断，IF=0表示不允许处理器响应可屏蔽中断请求信号，称为关中断。
④ SF：符号标志。SF=1表示运算结果的最高位为1。对于有符号数，在溢出标志OF=0时， SF=1表示运算结果为负，SF=0表示运算结果非负（正或零）。OF=1时，由于结果是错误的，所以符号位也和正确值相反。例如，两个负数相加产生溢出，此时 SF=0。对于无符号数运算，SF无意义（但是可以看出结果的大小规模）。
⑤ ZF：零标志。ZF=l 表示运算结果为零，减法运算后结果为零意味着两个参加运算的数大小相等；ZF=0，表示运算结果非零。
⑥ AF：辅助进位标志。它是两个BCD数运算时第3位上的进位，供运算后调整结果用，对其他数的运算没有意义。
⑦ PF：奇偶标志。PF=1 表示运算结果的低8位中有偶数个1；PF=0 表示有奇数个1。它可以用来进行奇偶校验。

⑧ CF：进位/借位标志。CF=1表示两个无符号数的加法运算有进位，或者是减法运算有借位，需要对它们的高位进行补充处理；CF=0 表示没有产生进位或借位。同样，进行有符号数运算时也会产生新的CF标志，此时程序员可以不关心CF标志。

## CPU的工作模式

32位的80x86微处理器有3种工作模式：实模式、保护模式和虚拟8086模式。

## 数据存放原则

低位部分在低地址，高位部分在高地址。

## 寄存器（端口）

（1）数据端口，用来存放要在外设和主机间传送的数据，实际上起数据缓冲作用。数据端口的传送方向可以是输入，也可以是输出。
（2）控制端口，传递CPU对外部设备的控制信号。该信号由CPU发出，传递到接口内的控制端口，然后发送到外部设备。例如启动磁盘工作。控制端口的传送方向总是输出。

（3）状态端口，用来协调外设与主机的同步。外设的工作状态在状态端口那里得到反映，CPU需要了解这个外设状态时，可以通过读状态端口，得到外设的状态，从而确定下一步的操作。例如某设备还没有准备好接收数据，你就不能向它发送数据。状态端口的传输方向总是输入。

## 调用外设的方式

1.直接使用调用指令 如 IN

2.使用BIOS与DOS例行程序调用外设

```
DOS系统功能INT 21H调用的方法如下。
（1）将调用功能的功能号存入AH寄存器。
（2）如必要，设置该调用功能的入口参数（调用参数）。
（3）执行INT 21H指令。
（4）如必要，按规定取得出口参数（返回参数）。
mov ah,9
int 21H
```

## 汇编语言工作文件

（1）编辑程序，如EDIT.COM。->.asm
（2）汇编程序，如MASM.EXE。->.obj
（3）连接程序，如LINK.EXE。->exe
（4）调试程序，如DEBUG.EXE。

com是一个段的文件

mac是宏

## DOS指令

1．盘：　　　；选择盘符:
2．CD　　　；选择目录
3．DIR　　　；显示目录和文件

4．REN　　　；改变文件名
5．CLS　　　；清除屏幕
6．DEL　　　；删除文件

7．MD　　　；建立目录
8．RD　　　；删除目录
9．COPY　　　；复制文件

10．TYPE 显示文本文件的内容
11．＞　　　；输出的重定向操作符
12．SETPATH 设置或显示可执行文件的搜索路径

13. HELP 显示命令格式和用法

## DOS系统调用

![dos系统调用](.\image\dos系统调用.jpg)

## 寻址方式

1. 立即寻址：操作数就在指令中，无需再到内存去取，用于直接指定一个常数送给寄存器

   ```
   MOV AL， 6H
   ```

   

2. 寄存器寻址 ：操作数就是寄存器中的值，用于指定两个寄存器作为操作数。

   ```
   MOV AX，BX
   ```

   

3. 直接寻址：操作数的有效[偏移]地址EA就在指令中，默认DS寄存器，用于直接指定一个变量作为操作数

   ```
   MOV AX，[4050H]
   ```

   

4. 寄存器间接寻址：操作数的有效地址EA就在寄存器中，用寄存器间接指向一个内存单元，寄存器的值不同，指向的内存单元的地址就不同。常用于循环程序中。

   ```
   MOV AX，[BX]　；默认DS寄存器作段地址
   MOV DX，[BP]　；默认SS寄存器作段地址
   ```

   

5. 寄存器相对寻址：操作数的有效地址EA是一个寄存器和位移量之和，适用于访问一维数组，寄存器可作为数组下标（或数组元素的位置），利用修改寄存器的值来定位数组中的各个元素。

   ```
   MOV AX，ARRY[BX]
   MOV AX，[ARRY][BX]
   MOV AX，[ARRY+BX]
   ```

   

6. 基址变址寻址：操作数的有效地址是一个基址寄存器和一个变址寄存器的内容之和，基址寄存器为BX和BP，变址寄存器为SI和DI，用于数组处理，数组的首地址可放在基址寄存器，利用修改变址寄存器的内容来定位数组中的各元素。

   ```
   MOV AX，[BX][SI]　；默认DS寄存器作段地址
   MOV AX，[BP][DI]　；默认SS寄存器作段地址
   MOV AX，ES:[BX][DI]　；指定ES寄存器作段地址
   ```

   

7. 相对基址变址寻址：有效地址是一个基址寄存器和一个变址寄存器以及一个位移量之和

   ```
   MOV AX，ARRY[BX][SI]　
   ```

## 操作数注意事项

- 双操作数指令的两个操作数，长度须匹配。
- 双操作数指令的两个操作数中，不能两个操作数同为内存单元，地址线无法同时给出两个变量的地址。

## 指令系统

通用格式：

```
[name]　operation　0perand　　[；comment]
[名字]　操作　操作数　　[；注释]
名字项是一个符号，可以是指令的标号，也可以是变量名。
操作项是一个操作码的助记符，它可以是指令、伪指令或宏指令名。
操作数项由一个或多个表达式组成，它提供该操作所要求的操作数或相关信息。
```

一般格式：

```
[标号:]　指令助记符　　[操作数]　　[；注释]
```

### 数据传送指令

- MOV（move）　　　传送
- PUSH（pushonto the stack）　进栈
- POP（pop from the stack）　出栈
- XCHG（exchange）　　交换
- IN（input）　输入
- OUT（output）　输出
- XLAT（translate）　换码bx+al
- LEA（load effective address）　有效地址送寄存器
- LDS（load DS with pointer）　指针送寄存器和DS
- LES（load ES with pointer）　指针送寄存器和ES
- LAHF（load AH with flags）　标志送AH寄存器
- SAHF（store AH into flags）　　AH送标志寄存器
- PUSHF（push flags）　　标志入栈
- POPF（pop flags）　　标志出栈

### 算术运算指令

- CBW（convert byte to word）　　字节扩展成字
- CWD（convert word to double word）　字扩展成双字
- ADD（add）　　加法
- ADC（add with carry）　带进位加法
- INC（increment）　加 1
- SUB（subtract）　　减法
- SBB（subtract with borrow）　带借位减法
- DEC（decrement）　　减 1
- NEG（negate）　　求补
- CMP（compare）　　比较
- MUL（unsigned mulutiple）　无符号数乘法
- IMUL（signedmulutiple）　带符号数乘法
- DIV（unsigned divide）　无符号数除法
- IDIV（signed divide）　带符号数除法
- DAA（decimal adjust for addition）　加法的十进制调整指令
- DAS（decimal adjust for subtraction）　减法的十进制调整指令
- AAA（ASCII adjust for addition）　加法的ASCII调整指令
- AAS（ASCII adjust for subtraction）　减法的ASCII调整指令
- AAM（ASCII adjust for multiplication）乘法的ASCII调整指令
- AAD（ASCII adjust for division）　除法的ASCII调整指令

### 逻辑与移位指令

- AND（and）　　与
- OR　（or）　　或
- NOT（not）　　非
- XOR（exclusive or）　异或
- TEST（test）　　测试
- SHL（shift logical left）　　逻辑左移

- SAL（shift arithmetic left）　算术左移
- SHR（shift logical right）　逻辑右移
- SAR（shift arithmetic right）　算术右移
- ROL（rotat left）　　循环左移
- ROR（rotat right）　　循环右移
- RCL（rotat left with carry）　带进位循环左移
- RCR（rotat right with carry）　带进位循环右移
  S
- HL 逻辑左移指令

### 串操作指令

- MOVS（move string）　串传送

- MOVSB　　（字节）
- MOVSW　　（字）
- REP前缀（repeat）　　　　　重复
- REPE/REPZ前缀（repeat while equal/zero）　　相等/为零则重复
- REPNE/REPNZ前缀（repeat while not equal/not zero）　不相等/不为零则重复
- CMPS（compare string）　串比较

- CMPSB　　（字节）
  CMPSW　　（字）

- SCAS（scan string）　串扫描

- SCASB　　　（字节）
  SCASW　　（字）

- STOS（store in to string）　存入串

- STOSB　　　（字节）
  STOSW　　（字）

- LODS（load from string）　从串取

- LODSB　　（字节）
  LODSW　　（字）

- CLD（cleardirection flag）　设置正向（向前，使DF=0，SI或DI自动加）
- STD（setdirection flag）　设置反向（向后，使DF=1，SI或DI自动减）

### 程序转移指令

- JMP（jmp）无条件跳转指令

- JMP　NEAR PTR 段内直接转移

- JMP　WORD PTR 段内间接转移

- JMP FAR PTR 段内直接转移

- JMP DWORD PTR 段内间接转移

- JX/JNX 条件转移X为标志寄存器名字第一个字符或者cx ， JZ,JNZ,JS,JNS,JO,JNO,JC,JB,JNAE,JNC,JNB,JAE,JP,JPE,JNP,JPO,JCXZ,JBE.JNBE

- JE,JL,JNL.JLE,JNLE
- LOOP（loop）循环
- LOOPZ/LOOPE（loop while zero, or equal）当为零/相等时循环
- LOOPNZ/LOOPNE（loop while not zero, or not equal）当不为零/不相等时循环
- CALL（call）调用指令
- RET（return）返回指令
- INT（interrupt）中断指令、
- IRET（ return from interrupt）从中断返回指令

### 处理机控制指令

- CLC（clear carry）　　进位位置 0
- CMC（complement carry）　进位位求反
- STC（set carry）　　进位位置 1
- CLD（clear direction）　方向标志位置0
- STD（set direction）　方向标志位置 1
- CLI（clear interrupt）　中断标志置 0
- STI（set interrupt）　中断标志置 1
- NOP　（no operation）　无操作
- HLT　（halt）　　停机
- WAIT（wait）　　等待
  LOCK（lock）　　封锁

### 80386指令系统新增

- MOVSX　　符号扩展传送
- MOVZX　　零扩展传送
- CWDE　　　16位符号扩展
- CDQ　　　32位符号扩展
- PUSHAD　　　32位通用寄存器入栈
- PUSHFD　　　32位标志寄存器入栈
- POPAD　　　32位通用寄存器出栈
- POPFD　　　32位标志寄存器出栈
- PUSH DWORD PTR imm32　32位立即数入栈
- LFS/LGS/LSS　地址传送
- SHLD　　双精度左移
- SHRD　　双精度右移
- BT　　位测试
- BTS　　位测试并置1
- BTR　　位测试并置0
- BTC　　位测试并反码
- BSF　　正向位扫描
- BSR　　反向位扫描
- INS/INSB/INSW/INSD　　串输入
- OUTS/OUTSB/OUTSW/OUTSD　串输出
- MOVSD　串移动
  CMPSD　　串比较
  SCASD　　串扫描
  STOSD　　串存储
- LODSD　　从串取
- IMUL　带符号数乘法
- XADD　交换并相加（486）
- CMPXCHG　比较并交换（486）
- BSWAP　字节交换（486）
- BOUND　界限检查
- ENTER　建立堆栈帧
- LEAVE　释放堆栈帧
- SETcc 根据指定的条件码设置0/1

##  语句类型

- 指令：在程序运行期间由计算机的CPU来执行
- 伪指令：在汇编程序对源程序进行汇编期间由汇编程序处理
- 宏指令

## 伪指令

### 处理机对应指令系统

- ·8086　选择 8086指令系统
- ·286　选择 8O286指令系统
- ·286P　选择保护方式下的 
- 80286指令系统
- ·386　选择 80386指令系统
- ·386P　选择保护方式下的 
- 8O386指令系统
- ·486　选择 80486指令系统
- ·486P　选择保护方式下的 
- 8O486指令系统
- ·586　选择Pentium指令系统
- ·586P 选择保护方式下的
- Pentium指令系统

### 段

```asm
;段定义
segment_name　SEGMENT
…
segment_name　ENDS
;确定用户定义的段和段寄存器的关系
ASSUME register_name:segment_name …，register_name:segment_name
;ASSUME伪指令只是指定把某个段分配给哪一个段寄存器，它并不能把段地址装入段寄存器中，所以在代码段中，还必须把段地址装入相应的段寄存器中。
;简化的段定义伪指令
·model　small　　；定义存储模型为 small.说明在内存中如何安排各个段
·data　　　；定义数据段 data
·code　　　；定义代码段 code
```

### 数据定义[内存]

一般格式

```
[变量] 操作码　N个操作数　[；注释]
```

- DB[define byte] 伪操作用来定义字节，其后的每个操作数都占有一个字节（8位）。
- DW 伪操作用来定义字，其后的每个操作数占有一个字（16 位，其低位字节在第一个字节地址中，高位字节在第二个字节地址中，即数据低位在低地址，数据高位在高地址）。
- DD 伪操作用来定义双字，其后的每个操作数占有两个字（32位）。
- DF 伪操作用来定义6个字节的字，其后的每个操作数占有48位。
- DQ 伪操作用来定义4个字，其后的每个操作数占有4个字（64位），可用来存放双精
  度浮点数。
- DT 伪操作用来定义10个字节，其后的每个操作数占有10个字节，为压缩的BCD码。

MASM6允许DB，DW，DD，DF，DQ，DT伪操作分别用BYTE，WORD， DWORD，FWORD，QWORD，TBYTE代替。

- RESB[reserve byte] 空出xx个字节

### 访问类型

WORD PTR　；字类型
BYTE PTR　；字节类型

THIS操作符 定义变量访问类型

LABEL伪操作 定义变量访问类型

### 进制设置

2：b

10：d

16：h

RADIX伪操作  基数改变为2～16范围内的任何基数

### 其他

- END [label] 汇编结束，程序起点label

- Expression_name EQU 定义表达式别名

- Expression 
  Expression_name = Expression 定义表达式别名

- 地址计数器$ 表示当前指令地址

- ORG constant expression  设置当前地址计数器$的值

- EVEN伪操作 使下一个变量或指令开始于偶数地址。

- ALIGN伪操作  使下一个变量的地址从4的倍数开始

- 数值回送操作符：TYPE、LENGTH、SIZE、OFFSET、SEG
- EXTRN  指出本模块中引用的符号名是其他模块中定义的符号名。如果符号名是变量，则类型应该是BYTE，WORD，DWORD等；如果符号名是标号或过程名，则类型为NEAR或FAR。引用的该符号名类型必须与定义的符号名类型相一致。
- PUBLIC，说明本模块中哪些子程序名、标号、变量名可以被其他模块引用，这些符号在本模块内部定义，当然也可以在本模块中引用。

### 过程定义

```asm
procedure_name　PROC　Attribute
  M
procedure_name　ENDP
```

## 分支向量表

branch 定义

## 子程序调用过程

主程序通过调用指令（CALL）进入子程序执行。该指令执行时，首先是把下一条指令的地址（返回地址），也就是当前IP寄存器的值（如果是远调，则还有CS寄存器的值）压入堆栈保存。然后把子程序的入口地址置入IP寄存器（如果是远调，则还有段地址置入CS寄存器），从而实现执行子程序。
子程序执行完毕，用返回指令（RET）回到主程序。返回指令把堆栈里保存的返回地址送回IP寄存器（如果是远调，则还有CS寄存器），从而实现从子程序返回到主程序继续执行。

## 参数传递方法

- 寄存器
- 变量
- 地址表
- 堆栈
- 结构变量：struc

## 与c组合

方法：用 C 语言编写主程序，用汇编语言编写子程序。将它们编写完成后，分别编译/汇编成目标文件（OBJ），然后把它们连接起来，形成可执行文件（EXE）

1. c中调用的asm要用extern声明，如同一般函数一样
2. 参数通过堆栈传送
3. 汇编返回值放在ax中

## 程序连接作用

1. 找到所有要连接的目标模块
2. 为所有段分配存储单元
3. 确定所有汇编无法确定的地址
4. 构成装入模块，形成可执行文件

## 段定义

.MODEL 内存模式定义伪指令

.DATA、 .DATA?、 .CONST近数据段

FARDATA[段名]和.FARDATA?[段名] 远数据段

.CODE[段名] 代码段

．STACK[堆栈大小] 堆栈段定义

．MASM预定义符号@CODE和@DATA

LISTMACRO　或  .XALL  列出产生目标码的宏展开。
.LISTMACROALL 或  .LALL  列出包括注释在内的所有宏展开。
.NOLISTMACRO　或  .SALL 不列出任何宏展开。

## 编程方法选择

子程序的设计方法可以实现程序复用，节省存储空间，优化程序结构。但参数不方便床底，断点转移与返回调用额外耗时

模块化的程序结构便于程序的调试和修改。

宏汇编语言提供的宏功能既可以实现程序复用，又能方便地传递多个参数，但是不省空间

## 宏汇编

### 格式

```asm
宏指令名 MACRO [形参1，形参2，…]
<宏定义体>
ENDM
```

宏定义的指令名可用伪指令PURGE来取消，然后重新定义。

### 特殊符号

形参中<>，可以将<>中的所有视作一整个直接代替

连接操作符&，组合两个符号，使之结合为一个符号

宏替换%，可以用值来替换，而非实参符号

local伪操作，界定标号为局部，防止多次调用造成的标号重复

include伪指令，引用宏文件，代码中就能直接使用这些宏

PURGE伪操作，取消一个宏，再重新定义

### 特殊汇编

```
重复汇编
REPT 表达式【重复次数】
…　（重复块）
ENDM
;-------------------------
不定次数重复汇编
IRP 形参，<实参 l，实参 2，…，实参 n>
…　（重复块）
ENDM
;------------------------
不定次数重复汇编-字符
IRPC 形参，字符串
…（重复块）
ENDM
;------------------------
条件汇编
IF××　条件表达式或参数
<语句体1>
[ELSE]
<语句体2>
ENDIF
```

条件汇编其他：

- IFE　表达式　　；表达式为 0，则满足条件

- IFDEF 符号　　；符号已定义或被说明为

  EXTRN，则满足条件

- IFNDEF 符号　　；符号未定义或未说明为

- EXTTRN，则满足条件

- IFB　<变量>　　；变量为空，则满足条件

- IFNB　<变量>　；变量不为空，则满足条件

- IFIDN　<串变量 1>，<串变量 2>　；2串相等，则满足条件

- IFNIDN　<串变量 1>，<串变量 2>　；2串不相等，则满足条件

- 关系和逻辑操作符，EQ，NE，LT，LE，GT，GE和逻辑操作符AND，OR

## I/O指令控制外设

外设沟通：使用DOS>BIOS>I/O指令

CPU与I/O设备的通信有三种信息，即控制信息、状态信息和数据信息，对应三种寄存器，这些寄存器称作端口port

### 端口分配

![外设端口](.\image\外设端口.jpg)

### 指令

IN　AL，PORT/DX　输入

OUT　PORT/DX， AL 输出

### 数据传送方式

1. 无条件传送：不管直接传
2. 查询传送：先查询状态，再传，串行执行等待
3. 中断传送：需要传送时，中断cpu，完后cpu自己玩
4. 直接存储传送DMA：外设直接和存储器数据交换

### 中断来源

内部软件-外部硬件

内部中断源：int、cpu计算错误、debug调试

外部中断源：不可屏蔽NMI、可屏蔽INTR

### 中断控制

- 中断屏蔽寄存器[8259A中断控制器]
- 中断命令寄存器

### 中断优先级

1. 内中断（除法错，INTO，INT）
2. 不可屏蔽中断（NMI）
3. 可屏蔽中断（INTR）-又分8级
4. 单步中断（调试程序）

### 中断处理过程

1. 中断请求
2. 中断优先级判别
3. 中断响应：取中断类型、cs|ip入栈保存、禁止中断、中断向量表取ip|cs调用中断处理程序
4. 中断处理：执行中断处理、后恢复现场
5. 中断返回：用EOI清除本次中断，用IPET恢复寄存器

### 中断程序设计

主程序

1. 设置中断向量并放入中断向量表中
2. 设置优先级和中断屏蔽位
3. 8259A和外设接口初始化
4. 设置开中断

中断处理程序设计

1. 保存寄存器内容
2. 若可中断嵌套设置开中断
3. 处理主体过程
4. 关中断，避免返回受到干扰
5. 恢复寄存器内容
6. 发中断结束命令EOI
7. 返回被中断程序IRET

## 输入输出

bios例行程序：存放在FE000H开始的8KB ROM中，为系统提供加电自检、引导装入系统、主要I/O设备的处理程序和接口控制，更为底层，是DOS的基础。

常用输入输出：

1. 键盘
2. 显示器
3. 定时器
4. 磁盘文件存取

### 定时器

原理：利用时钟与计数器进行计数减法，至0时输出信号。

实现步骤：

1. 告诉8253[定时芯片]使用哪个计数器，端口分别为40H\41H\42H，16位
2. 确定工作模式和计数初值，控制寄存器端口43H

作用：通过脉冲驱动扬声器，用高低电平信号来实现，扬声器端口61H，以不同的频率输出信号就能输出音乐

### 键盘

原理：按下键盘时，该键的9位扫描码通过端口60H输入主机，并触发键盘中断int 9，主机根据扫描码来确定敲入的键。

BIOS键盘中断：INT 16H

DOS键盘中断：INT 21H

实现：不需要键盘输入的功能调用，键盘输入的字符通过键盘硬件中断自动输入到键盘缓冲区中，程序只是从键盘缓冲区中读出键值并显示。

### 显示器

原理：显存中的内容直接映射到显示屏上，所以说显示屏是“存储器映像”。

bios显示操作中断：int 10h

显示方式存放单元：00449h

获取显示适配器性能：bios int 11h

### 文件存取

存取方式：

1. 以文件代号方式存取【随机存取】
2. 顺序存取
3. 随机存取
4. 随机分块存取

属性

1. 文件属性
2. 文件存取代码
3. 文件指针

读文件步骤：

1. .ASCII串=文件名（带路径），00H
2. .打开文件（ASCII串的地址作为调用参数）
3. .如果成功，获得一个文件代号handle
4. .根据文件代号handle读出文件的指定字节数到内存缓冲区
5. .关闭文件

写文件步骤：

1. .ASCII串=文件名（带路径），00H
2. .建立文件（ASCII串的地址作为调用参数）
3. .如果成功，获得一个文件代号handle
4. .根据文件代号handle，把指定的内存缓冲区字节数写到文件
5. .关闭文件