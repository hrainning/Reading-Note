# 30天自制操作系统

1. 考虑写一个一通电就能运行的程序
2. 写一个从磁盘读取操作系统的程序

过程：计算机默认读入第一个扇区，根据扇区内容执行操作，若扇区尾部为0x55,0xAA，则认为他是一个启动程序。

## 第一天

##### 工作

1. 用汇编编写了一个启动程序
2. 将其编译img镜像文件
3. 利用虚拟机或是软驱使用它

##### 额外：

1、汇编

- db、dd，dw - 写入x个字节的指令
- resb - 写入多个空字节
- $代表偏移量

2、启动程序写法

第一个扇区boot sectot总共512B，一次读取一个扇区

- 程序主体：定义磁盘的各种属性[FAT格式] 56字节 + 空18个字节
- 信息显示部分：74-509字节
- 启动程序标识：最后俩字节为0x55,0xAA，只有这样才认为第一个扇区是

3、FAT格式：预装文件系统，兼容性好

4、IPL：initial program loader，启动程序加载器[启动区]，共512字节。

##### 源码虚拟机使用方式

1. 复制到tolset
2. 点击!cons_xx.bat / 手动cmd
3. 输入asm，使用作者自制编译器nask将nas-》img
4. 输入run，使用qemu虚拟机执行img

## 第二天

##### 工作

程序：

1. 只保留启动区部分[512B]
2. 修改程序装载地址以及入口
3. 初始化段寄存器，以及源数据地址
4. 调用显卡bios，循环输出文字
5. 停止cpu

编译：

1. 使用makefile来帮助编译

##### 额外

1、汇编

- move ，复制数据
- add ，加法操作
- []，内存访问
- cmp，比较指令
- jmp，无条件跳转
- je，相等时跳转
- int，软件中断指令，显卡0x10
- hlt，让cpu进入待机状态
- org，指定程序的起点

2、内存地址使用

- 0号地址，bios程序各种功能实现
- 0xf0000号，bios程序本身
- 0x7c00[124] - 0x7dff，启动区内容装载地址

3、磁盘空间的使用

- 最初的512字节是启动区

3、makefile写法

```
xx:[ x1 x2]   #xx是块标号，x1、x2为需要存在的文件
	xxxx...  #执行指令
```

##### 源码使用方式

1. 双击!cons
2. 输入make，作者自制make，nas-》asm / bin / img / lst
3. 输入make run 【可以跳过make直接用】

## 第三天

##### 工作

1. 调用bios 的0x13号函数，实现将磁盘中的数据装入内存，读启动区后边存储的操作系统【包含差错，多次读取】
2. ipl启动区中，使用jmp跳转到实际操作系统程序存放地址继续执行
3. 调用显卡bios 0x10函数切换显示模式，并获取键盘状态，最后信息保存在内存中
4. 切换至32位模式
5. 导入c语言，并用汇编编写cpu停止程序HLT，c语言调用

##### 额外

1、汇编

- int 0x13， 调用bios的13号函数，对磁盘进行读、写、校验、寻道操作，需要指定柱面、扇区、磁头号、磁盘号，读是读到es:bx指定内存地址中

- JC ， jump if carry，进位标志的时候跳转

- JNC，jump if not carry，进位标志位0

- JAR，jump if above or equal大于等于时跳转

- JBE，jump if below or equal

- JB，jump if equal

- EQU，相当于#define，定义常量与=也差不多

- 默认段寄存器DS:

- ```asm
  ;编写函数格式
  ; naskfunc
  ; TAB=4
  [FORMAT "WCOFF"]                ; 制作目标文件的模式
  [BITS 32]                       ; 制作32位模式用的机械语言
  制作目标文件的信息
  [FILE "naskfunc.nas"]               ; 源文件名信息  *
          GLOBAL   _io_hlt        ; 程序中包含的函数名   *
  ;以下是实际的函数
  [SECTION .text]     ; 目标文件中写了这些之后再写程序
  _io_hlt:            ; void   io_hlt(void); *
          HLT
          RET
  ```

2、磁盘

- C0-H0-S1，0号磁柱，0磁头，1扇区为含ipl的启动区
- 一个扇区对应一个段
- 向一个空盘保存文件，文件名存在0x2600，文件内容0x4200

3、内存

- 0x7c00～0x7dff用于存放启动区
- x7e00以后直到0x9fbff没啥用
- 0x8000～0x81ff这512字节是留给启动区将要读取的信息放在那里的
- 0xa0000～0xaffff的64KB，显卡的内存地址

4、C

- 使用环境：必须为32位

- 文件后缀：.c

- 编译过程：.c -> asm - >obj -> link -> exe

- 起点：HariMain

- ```c
  //使用汇编中的程序格式
  *告诉C编译器，有一个函数在别的文件里*/
  void io_hlt(void);
  /*是函数声明却不用{ }，而用;，这表示的意思是：函数是在别的文件中，你自己找一下吧！*/
  /*是函数声明却不用{ }，而用;，这表示的意思是：函数是在别的文件中，你自己找一下吧！*/
  void HariMain(void)
  {
  fin:
      io_hlt(); /*执行naskfunc.nas里的_io_hlt*/
      goto fin;
  }
  ```

  

5、模式

- 16位和32位不兼容
- 32位保护模式
- 32位不能调用bios

## 第四天

##### 工作

1、通过汇编实现向显卡内存写入数据的函数[直接用指针更香]

2、用c的指针，编写绘制矩形的函数

##### 额外

1、c语言

- c只能和内存通过指针或者函数打交道，而无法和寄存器、设备直接进行信息交互
- 只有EAX \ ECX \ EDX能自由使用，寄存器只能读值，因为c语言生成的机器语言使用其他的
- c调用汇编的函数时，参数会放入ESP中，每个参数都是32位4字的

2、指令

- 后继版本的cpu指令能用于前辈的cpu，如486能送还给386
- IN ：从设备中获取信息
- OUT：将信息输出到设备中
- CLI：将中断标志置位0，表示忽略中断，使用之后用STI复原
- pushfd：将32位的标志寄存器压入栈
- popfd：将32位的eflasgs压入栈中
- 

3、汇编返回值

- RET：即返回EAX中的值

4、颜色

- RGB：#xxyyzz，对应RGB

5、设备码

- 调色板：0x3c8

## 第五天

##### 工作

1. 优化代码编写结构
2. 编写显示一个字体的函数
3. 引入osask字体数据，需要先生成二进制文件后与目标文件link，c中使用extern
4. 编写能显示字符串的函数，调用2
5. 绘制鼠标的图像，编写字体、放入vram内存中
6. c中定制gdt和idt指针，划分内存，并均初始化，预留前两个段

##### 额外

1、c语言

- c的struct：给变量定义类型的时候前边要+ struct
- sprintf函数：include < stdio > ，而后调用该函数(内存起点，字符串格式，变量1....)
- 输出格式说明：%d整数，%x十六进制数

2、显示字符串的方法

- 调用bios来实现，但是在32位模式下无法使用
- 直接在内存中绘制像素点来实现，可以使用字符库
- c语言中的sprintf函数，可以不适用任何操作系统功能，直接对内存进行操作，可以用于所有的操作系统。

3、GDT和IDT 

- GDT：global（segment）descriptor table，全局段号记录表，将段的信息排序记录在内存中，寄存器GDTR存放其起点以及有效个数
- 段的信息：size、起点、管理属性
- IDT：interrupt descriptor table，中断记录表，记录了0~255的中断码与调用函数的对应关系
- 中断机制的好处：被动检查变为主动申请

4、汇编

- LGDT：加载内存中的内容为GDT
- LIDT：加载内存中的内容为IDT