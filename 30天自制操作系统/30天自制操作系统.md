# 30天自制操作系统

1. 考虑写一个一通电就能运行的程序
2. 写一个从磁盘读取操作系统的程序

过程：计算机默认读入第一个扇区，根据扇区内容执行操作，若扇区尾部为0x55,0xAA，则认为他是一个启动程序。

## 第一天

##### 工作

1. 用汇编编写了一个启动程序
2. 将其编译img镜像文件
3. 利用虚拟机或是软驱使用它

##### 额外：

1、汇编

- db、dd，dw - 写入x个字节的指令
- resb - 写入多个空字节
- $代表偏移量

2、启动程序写法

第一个扇区boot sectot总共512B，一次读取一个扇区

- 程序主体：定义磁盘的各种属性[FAT格式] 56字节 + 空18个字节
- 信息显示部分：74-509字节
- 启动程序标识：最后俩字节为0x55,0xAA，只有这样才认为第一个扇区是

3、FAT格式：预装文件系统，兼容性好

4、IPL：initial program loader，启动程序加载器[启动区]，共512字节。

##### 源码虚拟机使用方式

1. 复制到tolset
2. 点击!cons_xx.bat / 手动cmd
3. 输入asm，使用作者自制编译器nask将nas-》img
4. 输入run，使用qemu虚拟机执行img

## 第二天

##### 工作

程序：

1. 只保留启动区部分[512B]
2. 修改程序装载地址以及入口
3. 初始化段寄存器，以及源数据地址
4. 调用显卡bios，循环输出文字
5. 停止cpu

编译：

1. 使用makefile来帮助编译

##### 额外

1、汇编

- move ，复制数据
- add ，加法操作
- []，内存访问
- cmp，比较指令
- jmp，无条件跳转
- je，相等时跳转
- int，软件中断指令，显卡0x10
- hlt，让cpu进入待机状态
- org，指定程序的起点

2、内存地址使用

- 0号地址，bios程序各种功能实现
- 0xf0000号，bios程序本身
- 0x7c00[124] - 0x7dff，启动区内容装载地址

3、磁盘空间的使用

- 最初的512字节是启动区

3、makefile写法

```
xx:[ x1 x2]   #xx是块标号，x1、x2为需要存在的文件
	xxxx...  #执行指令
```

##### 源码使用方式

1. 双击!cons
2. 输入make，作者自制make，nas-》asm / bin / img / lst
3. 输入make run 【可以跳过make直接用】

## 第三天

##### 工作

1. 调用bios 的0x13号函数，实现将磁盘中的数据装入内存，读启动区后边存储的操作系统【包含差错，多次读取】
2. ipl启动区中，使用jmp跳转到实际操作系统程序存放地址继续执行
3. 调用显卡bios 0x10函数切换显示模式，并获取键盘状态，最后信息保存在内存中
4. 切换至32位模式
5. 导入c语言，并用汇编编写cpu停止程序HLT，c语言调用

##### 额外

1、汇编

- int 0x13， 调用bios的13号函数，对磁盘进行读、写、校验、寻道操作，需要指定柱面、扇区、磁头号、磁盘号，读是读到es:bx指定内存地址中

- JC ， jump if carry，进位标志的时候跳转

- JNC，jump if not carry，进位标志位0

- JAR，jump if above or equal大于等于时跳转

- JBE，jump if below or equal

- JB，jump if equal

- EQU，相当于#define，定义常量与=也差不多

- 默认段寄存器DS:

- ```asm
  ;编写函数格式
  ; naskfunc
  ; TAB=4
  [FORMAT "WCOFF"]                ; 制作目标文件的模式
  [BITS 32]                       ; 制作32位模式用的机械语言
  制作目标文件的信息
  [FILE "naskfunc.nas"]               ; 源文件名信息  *
          GLOBAL   _io_hlt        ; 程序中包含的函数名   *
  ;以下是实际的函数
  [SECTION .text]     ; 目标文件中写了这些之后再写程序
  _io_hlt:            ; void   io_hlt(void); *
          HLT
          RET
  ```

2、磁盘

- C0-H0-S1，0号磁柱，0磁头，1扇区为含ipl的启动区
- 一个扇区对应一个段
- 向一个空盘保存文件，文件名存在0x2600，文件内容0x4200

3、内存

- 0x7c00～0x7dff用于存放启动区
- x7e00以后直到0x9fbff没啥用
- 0x8000～0x81ff这512字节是留给启动区将要读取的信息放在那里的
- 0xa0000～0xaffff的64KB，显卡的内存地址

4、C

- 使用环境：必须为32位

- 文件后缀：.c

- 编译过程：.c -> asm - >obj -> link -> exe

- 起点：HariMain

- ```c
  //使用汇编中的程序格式
  *告诉C编译器，有一个函数在别的文件里*/
  void io_hlt(void);
  /*是函数声明却不用{ }，而用;，这表示的意思是：函数是在别的文件中，你自己找一下吧！*/
  /*是函数声明却不用{ }，而用;，这表示的意思是：函数是在别的文件中，你自己找一下吧！*/
  void HariMain(void)
  {
  fin:
      io_hlt(); /*执行naskfunc.nas里的_io_hlt*/
      goto fin;
  }
  ```

  

5、模式

- 16位和32位不兼容
- 32位保护模式
- 32位不能调用bios

## 第四天

##### 工作

1、通过汇编实现向显卡内存写入数据的函数[直接用指针更香]

2、用c的指针，编写绘制矩形的函数

##### 额外

1、c语言

- c只能和内存通过指针或者函数打交道，而无法和寄存器、设备直接进行信息交互
- 只有EAX \ ECX \ EDX能自由使用，寄存器只能读值，因为c语言生成的机器语言使用其他的
- c调用汇编的函数时，参数会放入ESP中，每个参数都是32位4字的

2、指令

- 后继版本的cpu指令能用于前辈的cpu，如486能送还给386
- IN ：从设备中获取信息
- OUT：将信息输出到设备中
- CLI：将中断标志置位0，表示忽略中断，使用之后用STI复原
- pushfd：将32位的标志寄存器压入栈
- popfd：将32位的eflasgs压入栈中
- 

3、汇编返回值

- RET：即返回EAX中的值

4、颜色

- RGB：#xxyyzz，对应RGB

5、设备码

- 调色板：0x3c8

## 第五天

##### 工作

1. 优化代码编写结构
2. 编写显示一个字体的函数
3. 引入osask字体数据，需要先生成二进制文件后与目标文件link，c中使用extern
4. 编写能显示字符串的函数，调用2
5. 绘制鼠标的图像，编写字体、放入vram内存中
6. c中定制gdt和idt指针，划分内存，并均初始化，预留前两个段

##### 额外

1、c语言

- c的struct：给变量定义类型的时候前边要+ struct
- sprintf函数：include < stdio > ，而后调用该函数(内存起点，字符串格式，变量1....)
- 输出格式说明：%d整数，%x十六进制数

2、显示字符串的方法

- 调用bios来实现，但是在32位模式下无法使用
- 直接在内存中绘制像素点来实现，可以使用字符库
- c语言中的sprintf函数，可以不适用任何操作系统功能，直接对内存进行操作，可以用于所有的操作系统。

3、GDT和IDT 

- GDT：global（segment）descriptor table，全局段号记录表，将段的信息排序记录在内存中，寄存器GDTR存放其起点以及有效个数
- 段的信息：size、起点、管理属性
- IDT：interrupt descriptor table，中断记录表，记录了0~255的中断码与调用函数的对应关系
- 中断机制的好处：被动检查变为主动申请

4、汇编

- LGDT：加载内存中的内容为GDT
- LIDT：加载内存中的内容为IDT

## 第六天

##### 工作

1. 将大文件分割为多个功能的小文件，并改写makefile与头文件
2. 初始化PIC
3. c中编写鼠标键盘的中断程序，以及汇编中实现调用中断函数的程序【为了引入ITERTD指令】。需要额外编写PIC中断不完整的情况
4. 在idt中注册这个中断程序【设备的位置有规定，对应位置写入函数地址】，并修改pic中的imr开放鼠标键盘的中断

##### 额外

1、c语言

- include双引号说明在同一个文件夹中，<>说明头文件在编译器提供的文件李

2、汇编

- GDT共48位6个字节，前2个字节位段上限[GDT的有效字节数]，剩下32位为GDT地址。
- 段的信息：size：20位的段上限，单位是页 【1页4kb】；地址：32位；管理属性：12位，定义了这个段的运行权限，系统态用户态等。

3、PIC

- PIC,programmable interrupt controller,可编程中断控制器，是一组额外的芯片，共有主从两个，每一个有8路QRQ信号，从CPU角度来看属于外部设备，使用out进行初始化，作用是将中断信号送给cpu。中断时，cpu把pic传送进来的数据当作程序来执行。
- IMR，interrupt mask register，中断屏蔽寄存器，分别对应PIC八路IRQ信号，可屏蔽信号发送，防止混乱发送信号
- ICW，initial control word，初始化控制数据。ICW3是主从连接设定应该为3；ICW2决定了IRQ以哪一号中断通知CPU；
- 鼠标中断 - IRQ12 、键盘中断 - IRQ1

4、汇编

```
//书写中断程序方法
void xxx(int *esp)
{
    //需要这个程序执行的动作
    for (;;) {
        io_hlt();
    }
}
//还需要实现IRETD ，普通的return=RET不行
//汇编中实现
GLOBAL	_asm_xxx  //使得别的程序可调用
EXTERN	_xxx  //说明这是外部程序
_asm_xxx21:
		PUSH	ES
		PUSH	DS
		PUSHAD
		MOV		EAX,ESP
		PUSH	EAX
		MOV		AX,SS
		MOV		DS,AX
		MOV		ES,AX
		CALL	_xxx21
		POP		EAX
		POPAD
		POP		DS
		POP		ES
		IRETD
//将所有寄存器中的值存入栈中，执行完程序后再返回
//c语言中，认为es、ps、ss都指向同一个段，因此执行前需要先等于一波
```

- EXTERN：告诉编译器，这个函数在别的文件中
- call：调用函数

5、缓冲区 - 作用：信息保存到缓冲区中，而后再慢慢处理 - 种类：FIFO\FILO

6、中断过程

1. 键盘按下，触发中断 
2. 系统检查idt，调用对应的函数，将字符写入内存
3. 调用结束后，回到main的主函数中
4. 主函数检查到字符变量有内容转而执行显示
5. 主函数显示完毕后若无中断则返回继续进入原先停止与允许接收中断的状态

## 第七天

##### 工作

1. 实现可持续接受中断【告诉pic已经处理了中断使得pic可以继续接收别的中断】
2. 实现连续中断，先保留键盘输入值，而后开启接受中断。【别的中断程序执行完后，还能继续输出显示字符】
3. 分别构造fifo缓冲区来读取字符，接收鼠标移动数据
4. 设置鼠标的控制电路【包含在键盘里】模式为接收鼠标信息
5. main中编写当出现鼠标数据时的显示操作

##### 额外

1、汇编

- 端口为0x60设备，读取的信息就是键盘按键的编码
- 告诉键盘准备接收命令的端口为0x64，模式码为0x60，发送完之后要先确定好kbc准备好了才开始
- 键盘控制电路KBC的键盘工作模式的设定通过0x60端口来设置，利用鼠标的模式的模式码为0x47.

2、pic

- 鼠标的pic12为从，因此通知中断完成的时候，还需要通知主从连接的pic2。

## 第八天

##### 工作

1. 读取鼠标的具体数据【每次变换有3个动作数据】，并简单的处理，根据数据变换鼠标图标的位置

##### 额外

1、描绘方法

- 先用背景色覆盖，再涂上新的颜色

2、进入32位模式的过程

1. 禁止PIC1\PIC2和cpu的中断
2. 激活2A0GATE信号线【使用kbc符数端口，先告知0x64端口准备接受命令，再向0x60发送模式开启】
3. 随意读取GDT，再将CR0最高位设为0，最低位设置为1，从而进入保护模式，CR0寄存器 => control register 0，只有操作系统才能控制
4. 马上执行jmp，让指令重新解释一遍
5. 除了cs，所有段寄存器都设置为8
6. 复制磁盘中的内容到内存中，1、将asmhead和bootpack的代码连接，使得该代码可直接衔接后序的c编译过的代码；2、将启动区放入1mb以后的内存中，3、再传送其余内容的数据到其应该处于的位置。
7. 将bootpack的第0x10c8到0x11a8字节复制到0x310000内存中，并初始化栈
8. jmp跳转到bootpack开始执行【第二个段0x280000】

3、保护模式

- 段寄存器的解释为使用GDT，段设置无法改变，且不能使用操作系统专用段
- 变成保护模式后，机器语言的解释会发生变化
- cpu会使用管道加快指令执行速度
- 地址都是使用段寄存器指定的虚拟地址

4、内存分布

- 0~fffff：bios、vram等预留内容(1mb)
- 100000~267fff：软盘内容(1440kb) - 102600存放文件名 104200存放文件
- 268000~26f7ff：空(30kb)
- 26f800~26ffff：idt(2kb)
- 270000~27ffff：gdt(64kb)
- 280000~2fffff：系统代码(512kb)
- 300000~3fffff：栈与其他(1mb)
- 400000~

## 第九天

##### 工作

1. 程序整理，重写makefile
2. 检查内存size【先关闭缓存，再用c编写程序尝试写入检查】
3. 编写内存管理程序

##### 额外

1、cache

- 486以后的cpu都不直接和内存打交道，而是通过cache
- 关闭cache步骤：1、先检查eflags的ac位判断是否为486以后的cpu；2、对CR0寄存器进行修改；

2、检查c错误的时候，可以查看编译器，看是否与预期不同

3、内存管理

- 定义：管理空闲区以及使用区，并能给程序分配，记录free的size和address就可
- 算法：很多

## 第十天

##### 工作

1. 实现取整舍入函数，以4kb为单位进行free和alloc
2. 实现图层显示，并修改buff输出到图层
3. 使用局部刷新的方法优化速度

##### 额外

1、上下舍入算法

- 二进制可以用与运算来实现、
- 其他进制可以先除再乘来实现，或者减去取余

2、窗口叠加

- 用几张图层叠放存窗口
- 输出都往图层的内存输出
- 最终每一层逐层输出

## 第十一天

##### 工作

1. 修改鼠标不能越出屏幕的bug【超出时修正】
2. 化简函数
3. 绘制窗口，并显示
4. 编写循环的计数器
5. 优化图层刷新【只fresh变化的图层的上面的】
6. 优化图层刷新时的闪烁，【另开一个空间map，用来更新，vram显示map中的内容】

## 第十二天

##### 工作

1. 开启定时器的中断许可，编写定时器的中断函数并注册。【计算时间，超时统计】
2. 创建多个计时器【数值，每次更新全部】
3. 优化计时器中断处理的速度

##### 额外

1、计时器的作用

- 便于程序对时间的管理与计算，以及某些指令的执行
- 让不同的机器都能使用同一个时间

2、PIT

- programmable interval timer，可编程的间隔型定时器
- 设置PIT可以设置定时器隔几秒中断一次
- 在pic中连接着IRQ0
- 设置：先向0x42输出0x34表示要调整，再向0x40输出频率

3、编写IRQ0发生时调用的中断处理程序

- 编写中断程序 - c + asm  【行为+开放中断 + irerturn】
- 注册到idt上  -  c
- main中编写中断发生时，界面所作的响应。

4、当前中断程序的处理形式

1. 发生中断，pic向cpu发送信号

2. 根据idt调用对应的中断处理程序

3. 处理结束之后，ireturn并恢复所有寄存器【ire是从中断返回】

4. 回到的若是上一个中断程序，则继续其刚刚停下的动作，回到的若是main，则进行main里的循环啥的，判断变量是否有值

   。

5、超时

- 每隔一段时间，便设置出现某个动作

## 第十三天

##### 工作

1. 简化代码
2. 测试性能 【等10秒再显示，3秒时清空，初始化时间不一致】
3. 利用队列处理所有的中断显示
4. 利用list + 哨兵实现队列

##### 额外

1、性能影响

- 电脑温度
- 时钟频率变化
- 配置性能

## 第十四天

##### 工作

1. 优化代码以及执行时间
2. 使用高分辨
3. 让屏幕能显示字符串【根据输入改变输出】
4. 使得鼠标可以移动窗口

##### 额外

1、c语言

- for循环会编译为jmp，而jmp到不同的地址所执行的时间也会有所区别。
- static char编译的时候能直接翻译为db指令

2、中断禁止时间缩短的意义

- 即使只减少的一丢丢的时间，但是若有很多中断同时进行，也能提高系统的反应能力。

3、切换VBE画面模式

- ax = 0x4f02 , bx = 画面模式号码 ，再调用bios

## 第十五天

##### 工作

1. 实现任务切换的功能，并在规定时间内返回
2. 在中断处理中的若出现超时则进行任务切换

##### 额外

1、任务切换

- 频率：不宜太高，0.01就可
- 方法：把寄存器的值放入内存，再从内存把下一个成功许多寄存器读出来
- TTS：任务状态段，要在GDT中定义
- 任务切换的jmp：当jmp的目的地址为TTS则判定为是任务切换
- 不同的任务需要有各自的栈

2、汇编

- ip记录下一条指令在内存中的地址
- jmp的本质就是修改eip的指向
- jmp分两种，一种是段内跳转的near模式【只改EIP】，一种是跨段的模式far，任务切换就是far模式【改CS\EIP】。
- tr寄存器：记录当前正在运行的任务的编号*8
- ltr：向tr存入数据

3、任务切换功能的实现步骤

1. 编写修改tr【ltr】，初始化tr
2. 给每个任务编写函数
3. 为每一个任务创建各自的tts段
4. 为每个tts段分配内存空间
5. 切换任务【jmp】的函数  - asm
6. 任务函数绑定到tts段上的eip变量【jmp到这个段的时候就能自动调用了】

4、c

1. 任务切换中的程序不能写return，return返回的值的地址在esp的栈中，因为切换不是被程序直接调用，所以可能会出现问题，直接向esp中写入会更好

## 第十六天

##### 工作

1. 将所有程序都规划为任务，并以任务作为运行的单位
2. 让无事的任务休眠，有信息来的时候再唤醒
3. 绘制多个窗口，分别对应多个任务
4. 为任务添加优先级

##### 额外

1、休眠

- 休眠的任务依旧在队列中，但是添加了一个标记
- 优先级高的程序往往运行完后就休眠，不会打扰别的程序

## 第十七天

##### 工作

1. 实现一个空任务，当没有任务运行的时候执行htl
2. 实现tab切换窗口的功能
3. 实现+shift和capslock输入的功能
4. 控制键盘上的led灯

##### 额外

1、键盘

- 同时按两个shift与按左右shift三者输入的值不同
- capslock只有bios能知道，但是可以设置从别的地方读取

2、led的控制方法

- 读取状态寄存器，等bit1变为0
- 向端口0x60写入1个字节数据
- 等待键盘返回1个字节的信息
- 返回信息若为0xfa则表示发送成功

控制led状态，需要上述方法两次，向键盘发送edxx数据，xx的bit0代表scrolllock，bit1代表numlock，bit2代表capslock

## 第十八天

##### 工作

1. 控制只有输入的窗口光标才会闪烁
2. 支持空格【识别ascii，对其做出响应即可】
3. 设置窗口滚动
4. 实现mem命令显示内存
5. 实现cls命令清理屏幕
6. 实现dir命令显示文件

##### 额外

1、计算内存

- 内存管理器的参数就有说明

2、文件

- 从内存的102600开始，以32字节为循环写入文件名以及属性，若第一字节是0xe5则代表已经删除，8名+3后缀+1属性+10保留+2时间+2扇区+4大小

## 第十九天

##### 工作

1. 实现type命令 【cat】
2. 对fat格式支持
3. 创建一个应用程序，并运行

##### 额外

1、文件内容存储位置

- 磁盘地址计算：clustno*512 + 0x3e00 就是在磁盘中的实际位置

2、文件乱码解决

- 0x9 - 制表符 0x0a - 换行符 0x0d - 回车符 需要转换为可以显示的格式。
- window回车：0xd 0xa -》换行+回到行首
- linux回车: 0xa -》一步到位

3、FAT (file allocation table)

- 位置：位于从0柱面，0磁头，2扇区开始的9个扇区中，0x200~0x13ff，备份放在0x1400~0x25ff
- 功能：记录文件在磁盘中存放的位置的表
- 查看：先解压缩才能查看，3个字节为一组，中间向两边对换，即可还原。

4、运行应用程序步骤

1. 根据文件名找到文件
2. 读取文件到内存中【需分配】
3. jmp到内存上执行

## 第二十天

##### 工作

1. 编写系统函数
2. 编写调用系统功能的api【调用系统函数的asm，用call直接调用c中代码】，并注册到idt中  - 可以通过寄存器来实现1个int就能调用不同的函数 
3. 应用程序用int 调用 api

##### 额外

1、汇编

- call和jmp的区别：call会把下次要返回的地址压入栈中，其他相同
- 调用c的时候使用栈来传递参数
- far-call就需要相应的使用far-ret【RETF】，而非普通的ret，而int就要用iretd
- 编写api之后，若不注册到idt中，应用程序只能根据内存地址来实现call调用，而此地址又会随着系统代码的改变而改变，每次都要重新编写api，因此注册了更好，可以用中断的方法调用。

## 第二十一天

##### 工作



##### 额外