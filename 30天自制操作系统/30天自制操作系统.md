# 30天自制操作系统

1. 考虑写一个一通电就能运行的程序
2. 写一个从磁盘读取操作系统的程序

过程：计算机默认读入第一个扇区，根据扇区内容执行操作，若扇区尾部为0x55,0xAA，则认为他是一个启动程序。

## 第一天

##### 工作

1. 用汇编编写了一个启动程序
2. 将其编译img镜像文件
3. 利用虚拟机或是软驱使用它

##### 额外：

1、汇编

- db、dd，dw - 写入x个字节的指令
- resb - 写入多个空字节
- $代表偏移量

2、启动程序写法

第一个扇区boot sectot总共512B，一次读取一个扇区

- 程序主体：定义磁盘的各种属性[FAT格式] 56字节 + 空18个字节
- 信息显示部分：74-509字节
- 启动程序标识：最后俩字节为0x55,0xAA，只有这样才认为第一个扇区是

3、FAT格式：预装文件系统，兼容性好

4、IPL：initial program loader，启动程序加载器[启动区]，共512字节。

##### 源码虚拟机使用方式

1. 复制到tolset
2. 点击!cons_xx.bat / 手动cmd
3. 输入asm，使用作者自制编译器nask将nas-》img
4. 输入run，使用qemu虚拟机执行img

## 第二天

##### 工作

程序：

1. 只保留启动区部分[512B]
2. 修改程序装载地址以及入口
3. 初始化段寄存器，以及源数据地址
4. 调用显卡bios，循环输出文字
5. 停止cpu

编译：

1. 使用makefile来帮助编译

##### 额外

1、汇编

- move ，复制数据
- add ，加法操作
- []，内存访问
- cmp，比较指令
- jmp，无条件跳转
- je，相等时跳转
- int，软件中断指令，显卡0x10
- hlt，让cpu进入待机状态
- org，指定程序的起点

2、内存地址使用

- 0号地址，bios程序各种功能实现
- 0xf0000号，bios程序本身
- 0x7c00[124] - 0x7dff，启动区内容装载地址

3、磁盘空间的使用

- 最初的512字节是启动区

3、makefile写法

```
xx:[ x1 x2]   #xx是块标号，x1、x2为需要存在的文件
	xxxx...  #执行指令
```

##### 源码使用方式

1. 双击!cons
2. 输入make，作者自制make，nas-》asm / bin / img / lst
3. 输入make run 【可以跳过make直接用】

## 第三天

##### 工作

1. 调用bios 的0x13号函数，实现将磁盘中的数据装入内存【包含差错，多次读取】
2. 使用jmp跳转到实际操作系统地址并继续执行
3. 调用显卡bios 0x10函数切换显示模式，并获取键盘状态
4. 切换至32位模式
5. 导入c语言，并编写cpu停止程序

##### 额外

