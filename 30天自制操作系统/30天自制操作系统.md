# 30天自制操作系统

1. 考虑写一个一通电就能运行的程序
2. 写一个从磁盘读取操作系统的程序

过程：计算机默认读入第一个扇区，根据扇区内容执行操作，若扇区尾部为0x55,0xAA，则认为他是一个启动程序。

## 第一天

##### 工作

1. 用汇编编写了一个启动程序
2. 将其编译img镜像文件
3. 利用虚拟机或是软驱使用它

##### 额外：

1、汇编

- db、dd，dw - 写入x个字节的指令
- resb - 写入多个空字节
- $代表偏移量

2、启动程序写法

第一个扇区boot sectot总共512B，一次读取一个扇区

- 程序主体：定义磁盘的各种属性[FAT格式] 56字节 + 空18个字节
- 信息显示部分：74-509字节
- 启动程序标识：最后俩字节为0x55,0xAA，只有这样才认为第一个扇区是

3、FAT格式：预装文件系统，兼容性好

4、IPL：initial program loader，启动程序加载器[启动区]，共512字节。

##### 源码虚拟机使用方式

1. 复制到tolset
2. 点击!cons_xx.bat / 手动cmd
3. 输入asm，使用作者自制编译器nask将nas-》img
4. 输入run，使用qemu虚拟机执行img

## 第二天

##### 工作

程序：

1. 只保留启动区部分[512B]
2. 修改程序装载地址以及入口
3. 初始化段寄存器，以及源数据地址
4. 调用显卡bios，循环输出文字
5. 停止cpu

编译：

1. 使用makefile来帮助编译

##### 额外

1、汇编

- move ，复制数据
- add ，加法操作
- []，内存访问
- cmp，比较指令
- jmp，无条件跳转
- je，相等时跳转
- int，软件中断指令，显卡0x10
- hlt，让cpu进入待机状态
- org，指定程序的起点

2、内存地址使用

- 0号地址，bios程序各种功能实现
- 0xf0000号，bios程序本身
- 0x7c00[124] - 0x7dff，启动区内容装载地址

3、磁盘空间的使用

- 最初的512字节是启动区

3、makefile写法

```
xx:[ x1 x2]   #xx是块标号，x1、x2为需要存在的文件
	xxxx...  #执行指令
```

##### 源码使用方式

1. 双击!cons
2. 输入make，作者自制make，nas-》asm / bin / img / lst
3. 输入make run 【可以跳过make直接用】

## 第三天

##### 工作

1. 调用bios 的0x13号函数，实现将磁盘中的数据装入内存，读启动区后边存储的操作系统【包含差错，多次读取】
2. ipl启动区中，使用jmp跳转到实际操作系统程序存放地址继续执行
3. 调用显卡bios 0x10函数切换显示模式，并获取键盘状态，最后信息保存在内存中
4. 切换至32位模式
5. 导入c语言，并用汇编编写cpu停止程序HLT，c语言调用

##### 额外

1、汇编

- int 0x13， 调用bios的13号函数，对磁盘进行读、写、校验、寻道操作，需要指定柱面、扇区、磁头号、磁盘号，读是读到es:bx指定内存地址中

- JC ， jump if carry，进位标志的时候跳转

- JNC，jump if not carry，进位标志位0

- JAR，jump if above or equal大于等于时跳转

- JBE，jump if below or equal

- JB，jump if equal

- EQU，相当于#define，定义常量与=也差不多

- 默认段寄存器DS:

- ```asm
  ;编写函数格式
  ; naskfunc
  ; TAB=4
  [FORMAT "WCOFF"]                ; 制作目标文件的模式
  [BITS 32]                       ; 制作32位模式用的机械语言
  制作目标文件的信息
  [FILE "naskfunc.nas"]               ; 源文件名信息  *
          GLOBAL   _io_hlt        ; 程序中包含的函数名   *
  ;以下是实际的函数
  [SECTION .text]     ; 目标文件中写了这些之后再写程序
  _io_hlt:            ; void   io_hlt(void); *
          HLT
          RET
  ```

2、磁盘

- C0-H0-S1，0号磁柱，0磁头，1扇区为含ipl的启动区
- 一个扇区对应一个段
- 向一个空盘保存文件，文件名存在0x2600，文件内容0x4200

3、内存

- 0x7c00～0x7dff用于存放启动区
- x7e00以后直到0x9fbff没啥用
- 0x8000～0x81ff这512字节是留给启动区将要读取的信息放在那里的
- 0xa0000～0xaffff的64KB，显卡的内存地址

4、C

- 使用环境：必须为32位

- 文件后缀：.c

- 编译过程：.c -> asm - >obj -> link -> exe

- 起点：HariMain

- ```c
  //使用汇编中的程序格式
  *告诉C编译器，有一个函数在别的文件里*/
  void io_hlt(void);
  /*是函数声明却不用{ }，而用;，这表示的意思是：函数是在别的文件中，你自己找一下吧！*/
  /*是函数声明却不用{ }，而用;，这表示的意思是：函数是在别的文件中，你自己找一下吧！*/
  void HariMain(void)
  {
  fin:
      io_hlt(); /*执行naskfunc.nas里的_io_hlt*/
      goto fin;
  }
  ```

  

5、模式

- 16位和32位不兼容
- 32位保护模式
- 32位不能调用bios

## 第四天

##### 工作

1、通过汇编实现向显卡内存写入数据的函数[直接用指针更香]

2、用c的指针，编写绘制矩形的函数

##### 额外

1、c语言

- c只能和内存通过指针或者函数打交道，而无法和寄存器、设备直接进行信息交互
- 只有EAX \ ECX \ EDX能自由使用，寄存器只能读值，因为c语言生成的机器语言使用其他的
- c调用汇编的函数时，参数会放入ESP中，每个参数都是32位4字的

2、指令

- 后继版本的cpu指令能用于前辈的cpu，如486能送还给386
- IN ：从设备中获取信息
- OUT：将信息输出到设备中
- CLI：将中断标志置位0，表示忽略中断，使用之后用STI复原
- pushfd：将32位的标志寄存器压入栈
- popfd：将32位的eflasgs压入栈中
- 

3、汇编返回值

- RET：即返回EAX中的值

4、颜色

- RGB：#xxyyzz，对应RGB

5、设备码

- 调色板：0x3c8

## 第五天

##### 工作

1. 优化代码编写结构
2. 编写显示一个字体的函数
3. 引入osask字体数据，需要先生成二进制文件后与目标文件link，c中使用extern
4. 编写能显示字符串的函数，调用2
5. 绘制鼠标的图像，编写字体、放入vram内存中
6. c中定制gdt和idt指针，划分内存，并均初始化，预留前两个段

##### 额外

1、c语言

- c的struct：给变量定义类型的时候前边要+ struct
- sprintf函数：include < stdio > ，而后调用该函数(内存起点，字符串格式，变量1....)
- 输出格式说明：%d整数，%x十六进制数

2、显示字符串的方法

- 调用bios来实现，但是在32位模式下无法使用
- 直接在内存中绘制像素点来实现，可以使用字符库
- c语言中的sprintf函数，可以不适用任何操作系统功能，直接对内存进行操作，可以用于所有的操作系统。

3、GDT和IDT 

- GDT：global（segment）descriptor table，全局段号记录表，将段的信息排序记录在内存中，寄存器GDTR存放其起点以及有效个数
- 段的信息：size、起点、管理属性
- IDT：interrupt descriptor table，中断记录表，记录了0~255的中断码与调用函数的对应关系
- 中断机制的好处：被动检查变为主动申请

4、汇编

- LGDT：加载内存中的内容为GDT
- LIDT：加载内存中的内容为IDT

## 第六天

##### 工作

1. 将大文件分割为多个功能的小文件，并改写makefile与头文件
2. 初始化PIC
3. c中编写鼠标键盘的中断程序，以及汇编中实现调用中断函数的程序【为了引入ITERTD指令】。需要额外编写PIC中断不完整的情况
4. 在idt中注册这个中断程序【设备的位置有规定，对应位置写入函数地址】，并修改pic中的imr开放鼠标键盘的中断

##### 额外

1、c语言

- include双引号说明在同一个文件夹中，<>说明头文件在编译器提供的文件李

2、汇编

- GDT共48位6个字节，前2个字节位段上限[GDT的有效字节数]，剩下32位为GDT地址。
- 段的信息：size：20位的段上限，单位是页 【1页4kb】；地址：32位；管理属性：12位，定义了这个段的运行权限，系统态用户态等。

3、PIC

- PIC,programmable interrupt controller,可编程中断控制器，是一组额外的芯片，共有主从两个，每一个有8路QRQ信号，从CPU角度来看属于外部设备，使用out进行初始化，作用是将中断信号送给cpu。中断时，cpu把pic传送进来的数据当作程序来执行。
- IMR，interrupt mask register，中断屏蔽寄存器，分别对应PIC八路IRQ信号，可屏蔽信号发送，防止混乱发送信号
- ICW，initial control word，初始化控制数据。ICW3是主从连接设定应该为3；ICW2决定了IRQ以哪一号中断通知CPU；
- 鼠标中断 - IRQ12 、键盘中断 - IRQ1

4、汇编

```
//书写中断程序方法
void xxx(int *esp)
{
    //需要这个程序执行的动作
    for (;;) {
        io_hlt();
    }
}
//还需要实现IRETD ，普通的return=RET不行
//汇编中实现
GLOBAL	_asm_xxx  //使得别的程序可调用
EXTERN	_xxx  //说明这是外部程序
_asm_xxx21:
		PUSH	ES
		PUSH	DS
		PUSHAD
		MOV		EAX,ESP
		PUSH	EAX
		MOV		AX,SS
		MOV		DS,AX
		MOV		ES,AX
		CALL	_xxx21
		POP		EAX
		POPAD
		POP		DS
		POP		ES
		IRETD
//将所有寄存器中的值存入栈中，执行完程序后再返回
//c语言中，认为es、ps、ss都指向同一个段，因此执行前需要先等于一波
```

- EXTERN：告诉编译器，这个函数在别的文件中
- call：调用函数

5、缓冲区 - 作用：信息保存到缓冲区中，而后再慢慢处理 - 种类：FIFO\FILO

6、中断过程

1. 键盘按下，触发中断 
2. 系统检查idt，调用对应的函数，将字符写入内存
3. 调用结束后，回到main的主函数中
4. 主函数检查到字符变量有内容转而执行显示
5. 主函数显示完毕后若无中断则返回继续进入原先停止与允许接收中断的状态

## 第七天

##### 工作

1. 实现可持续接受中断【告诉pic已经处理了中断使得pic可以继续接收别的中断】
2. 实现连续中断，先保留键盘输入值，而后开启接受中断。【别的中断程序执行完后，还能继续输出显示字符】
3. 分别构造fifo缓冲区来读取字符，接收鼠标移动数据
4. 设置鼠标的控制电路【包含在键盘里】模式为接收鼠标信息
5. main中编写当出现鼠标数据时的显示操作

##### 额外

1、汇编

- 端口为0x60设备，读取的信息就是键盘按键的编码
- 告诉键盘准备接收命令的端口为0x64，模式码为0x60，发送完之后要先确定好kbc准备好了才开始
- 键盘控制电路KBC的键盘工作模式的设定通过0x60端口来设置，利用鼠标的模式的模式码为0x47.

2、pic

- 鼠标的pic12为从，因此通知中断完成的时候，还需要通知主从连接的pic2。

## 第八天

##### 工作

1. 读取鼠标的具体数据【每次变换有3个动作数据】，并简单的处理，根据数据变换鼠标图标的位置

##### 额外

1、描绘方法

- 先用背景色覆盖，再涂上新的颜色

2、进入32位模式的过程

1. 禁止PIC1\PIC2和cpu的中断
2. 激活2A0GATE信号线【使用kbc符数端口，先告知0x64端口准备接受命令，再向0x60发送模式开启】
3. 随意读取GDT，再将CR0最高位设为0，最低位设置为1，从而进入保护模式，CR0寄存器 => control register 0，只有操作系统才能控制
4. 马上执行jmp，让指令重新解释一遍
5. 除了cs，所有段寄存器都设置为8
6. 复制磁盘中的内容到内存中，1、将asmhead和bootpack的代码连接，使得该代码可直接衔接后序的c编译过的代码；2、将启动区放入1mb以后的内存中，3、再传送其余内容的数据到其应该处于的位置。
7. 将bootpack的第0x10c8到0x11a8字节复制到0x310000内存中，并初始化栈
8. jmp跳转到bootpack开始执行【第二个段0x280000】

3、保护模式

- 段寄存器的解释为使用GDT，段设置无法改变，且不能使用操作系统专用段
- 变成保护模式后，机器语言的解释会发生变化
- cpu会使用管道加快指令执行速度
- 地址都是使用段寄存器指定的虚拟地址

4、内存分布

- 0~fffff：bios、vram等预留内容(1mb)
- 100000~267fff：软盘内容(1440kb)
- 268000~26f7ff：空(30kb)
- 26f800~26ffff：idt(2kb)
- 270000~27ffff：gdt(64kb)
- 280000~2fffff：系统代码(512kb)
- 300000~3fffff：栈与其他(1mb)
- 400000~

## 第九天

##### 工作

1. 程序整理，重写makefile
2. 检查内存size【先关闭缓存，再用c编写程序尝试写入检查】
3. 编写内存管理程序

##### 额外

1、cache

- 486以后的cpu都不直接和内存打交道，而是通过cache
- 关闭cache步骤：1、先检查eflags的ac位判断是否为486以后的cpu；2、对CR0寄存器进行修改；

2、检查c错误的时候，可以查看编译器，看是否与预期不同

3、内存管理

- 定义：管理空闲区以及使用区，并能给程序分配，记录free的size和address就可
- 算法：很多

## 第十天

##### 工作

1. 实现取整舍入函数，以4kb为单位进行free和alloc
2. 实现图层显示，并修改buff输出到图层
3. 使用局部刷新的方法优化速度

##### 额外

1、上下舍入算法

- 二进制可以用与运算来实现、
- 其他进制可以先除再乘来实现，或者减去取余

2、窗口叠加

- 用几张图层叠放存窗口
- 输出都往图层的内存输出
- 最终每一层逐层输出

## 第十一天

##### 工作

1. 修改鼠标不能越出屏幕的bug【超出时修正】
2. 化简函数
3. 绘制窗口，并显示
4. 编写循环的计数器
5. 优化图层刷新【只fresh变化的图层的上面的】
6. 优化图层刷新时的闪烁，【另开一个空间map，用来更新，vram显示map中的内容】

## 第十二天

##### 工作

##### 额外