## C++语言相较于C

- 类和对象
- 继承
- 多态、虚函数、RTTl
- 函数重载
- 引用变量
- 泛型编程【模板】
- 处理错误条件的异常机制
- 管理函数、类、变量名的名称空间

## C++编程方式

- 面向过程编程【c】：强调的是编程的算法
- 面向对象编程：设计与问题本身特征相对应的数据结构【数据】
- 泛型编程：使重用和抽象通用概念技术更简单【算法独立于特定数据类型】

## 程序的组成

算法+数据

## 程序创建的步骤

1. 源代码
2. 编译器
3. 目标代码
4. 链接程序【启动代码+库代码】
5. 可执行代码

## G++源文件需要添加标识

要求添加标记：-std=c++11 use_auto.cpp

## 程序的组成

函数头+函数体

## main是否必须？

1. 动态链接库【DDL】不用
2. 用于专用环境的程序可能不用，如机器人
3. 某些框架程序有隐藏的main会自动调用

## 头文件命名方式

1. c => 扩展名.h
2. c++ => 1\无拓展名的  2\c的旧式风格 3\c的转换,去掉拓展名,头部+c

## 头文件的处理[#编译指令]

预处理器处理以#开头的编译指令，使得头文件中的内容添加到程序组成一个复合文件，一起被发送给编译器。

## 空间管理技术[Using 编译指令]

- 定位:是c++支持的一项新特性
- 作用:当两个封装好的产品使用了同名函数时,可以通过命名空间来限定使用的是哪个函数定义
- std:c++标准组件的命名空间[带扩展名.h的不需要指定空间]

使用

- 指定使用整个空间: using namespace xx;
- 指定使用某个空间中的函数:using std::xx;
- 也可以在使用某个函数时添加: std::xx

## '<<'与'>>'含义

含义1:插入运算符

指出了信息的流向路径,如cout

cout<<解释:信息插入了输出流中,cout是一个流对象,包括了一个插入运算符<<

含义2:左移运算符

## endl控制符

输入流中插入会导致屏幕中的光标移动到下一行

与转移符\n的区别:输出换行符的同时刷新缓冲区，相当于cout<<'\n'<<std::flush;

## 标记

token,代码中不可用空格分割的元素.

## 语句

1. 定义声明语句:定义了需要的内存以及该内存单元的名称
2. 引用声明语句:使计算机能使用在其他地方定义的变量
3. 赋值语句
4. cout/cin:可以自动转化数据类型为字符串

## 传递消息的方法

1. 使用类方法
2. 重载预算符:<<

## 提供函数原型的方法

函数原型:描述函数的接口

1. 在源代码中输入函数原型[参数中有用的只有参数类型]
2. 头文件中定义

函数不允许嵌套定义,且放在main后定义比较好

函数名不可用关键字,其他符合规则都可

## main函数中的返回值返给谁

返回os中的调用程序[shell等]了,通常约定0为正常允许

## 语句类型

1. 声明语句:定义函数中使用的变量名和类型
2. 赋值语句:使用赋值运算符给变量赋值
3. 消息语句:将消息发送给对象,激发某种行为
4. 函数调用:执行函数
5. 函数原型:描述函数的接口
6. 返回语句:将一个值从被调用函数返回到调用函数中

## 数据类型

基本数据类型:整数[char-short-int-long-long long]\浮点数

复合数据类型:数组\字符串\指针\结构

## 变量命名规则

双下划线或大写开头的被保留给编译器及其适用的资源,单下划线留给全局变量

## c++字节的定义

寻常的字节:8bit

要求字节至少能容纳实现的基本字符集的相邻位[根据编码方式判断,如unicode就要16位的字节],依赖于实现

## 头文件climits[limits.h]

包含了关于整型的限制信息,既定义表示各种限制的符号名称,如INT_MAX

## #define

定义符号常量

预处理时,程序中所有此定义的字段都会被替换

一般适用const更好

## C++11特殊的赋值方式

利用{}来对变量赋值如: int a = {1}; 或 int a{1};

有助于防范类型转换错误

## c++额外的赋值语法

利用()来对变量赋值 :int a(1);

## c++设置cout的进制

cout<<dec;=>设置为10进制

cout<<hex;=>设置为16进制

cout<<oct;=>设置为8进制

## C++中常量的数据类型

默认：尽可能使用int类型

对于带后缀的数字常量[l、u、ul、ull]：

根据后缀决定改数值为什么类型

对于不带后缀的数字常量

十进制：能存的最小类型  int 、long、long long

八、十六进制：int、unsigned int、long、unsigned long、long long 

16进制常表示内存地址，而地址为无符号的，用unsigned int 比long更合适。

## cout输出一个字符

cout.put()，数值会转变为字符输出

## c++扩展字符集

字符名可以用\u或者\U开头使用unicode编码

## 整型char的符号

char的是否有符号是由c++的实现来决定的，若要显式指定，可以用unsigned或signed来指定

## 8位的char不够使用如何解决

方法1：编译器将一个字节定义位16位或32位

方法2：使用wchar_t，其可以表示系统使用的最大扩展字符集，需要用wcout或wcin来输入输出,用L前缀来标识

方法3：使用c++11新增类型char16_t或char32_t，用u或U前缀标识

## bool类型

0为假，其余为真

## 符号常量

定义符号常量的两种方法：#define 和const限定符

const是c++新增的，尽量用sonst

const有点：1、能明确指定类型2、可以限制作用域在特定函数中3、可以用于更复杂的数据类型

## 浮点数内部存储

分为基准数和缩放因子，基准数<1。都以二进制存储

## 浮点数的类型

float：至少32

double：至少48，一般64

long double：至少double

## 浮点数的表示方法

小数点格式的定点表示法

用E/e的科学计数法

## 浮点数的输出格式控制

使用setf()函数迫使使用定点表示法，用法

cout.setf(ios_base::fixed,ios_base::floatfield);

## 浮点数常量类型

默认用double

后缀f为float

后缀l为long double

## 浮点数优缺点

优点：表示的范围更大

缺点：计算速度与精度降低【做运算时结果可能有偏差】

## %运算符

取模运算，两个参数均要为整数

## 初始化时数值类型转换

浮点数-》整数：会丢失所有小数

大的数-》小范围类型：浮点数值是不确定的，整数只保留小的

C++11中的{ }赋值操作不允许缩窄【既大-》小类型】

## 传递参数时的类型转换

通常由c++函数原型控制，若不使用则：char/short进行整型提升，float》double

## 表达式的类型转换

short》int

小范围-》大范围

尽可能的有符号

## 强制类型转换

typeName (value)  

(typeName) value  ： 原始的c

static_cast< typeName > (value)   ：转换更严格

## 自动类型

auto类型，在初始化的时候根据赋值的值自动确定变量的类型

## sizeof

返回的是字节长度

## 数组初始化【使用{}】

只能在声明的时候使用，普通的变量可以在之后使用

## strlen

从数组第一个元素开始，计算字节数量，直到遇到第一个空字符为止

## 字符串

c-风格：用char数组来表示

该数组末尾必须为'/0'，否则不为字符串

初始化可以用字符串常量“ ”，或者{}

cout输出字符串是根据末尾空字符来决定是否停止的，由于内内存中有很多空字符，所以很快就会停止。

可以用cin输入字符串，但不能防止超出数组size的字符串输入，会覆盖数组中后方的内存空间

cin根据空格来分割输入，没被读取的字段依然会保留在输入流中等待下次的cin

复制通过strcpy(字符串1，字符串2)

拼接使用strcat(字符串1，字符串2)

但是复制和拼接都有覆盖相邻内存的危险，导致终止或继续运行数据被破坏，可以用strncpy与strncat来避免

内容未定义的数组长度不可预测

c++：string类来存储字符串

比char数组更安全与方便，可以当作变量来使用

可以可以直接用等号=

拼接与附加可以直接用+号，可以与char数组混合使用

string类长度计算可以用类方法size()或常规函数strlen()来判断字符数量

## 字符串常量

字符串常量返回的是内存地址

拼接时两个字符串放在一起就可，前一个字符串的空字符自动被取代

末尾自动+‘\0’

strlen()：可以获取字符串字符数，不计算空字符【与数组无关】

## 面向行的输入

利用cin类中的getline()函数或是get()函数读取整行

cin.getline(数组名，size)：读取足够数量或遇到换行时停止,存储字符串时用空字符来代替换行符

get(数组名，size)：与getline的区别，读取时遇到换行符会将其保留在输入队列里面，所以会出现连续两次get，第二次读不到任何内容。

get解决方法：1、不带参数的get()可以读取任意下一个字符，因此可以用它来处理换行符。2、cin.get(xx,xx)返回的是cin对象，因此可以用cin.get(xx,xx).get()顺手读掉换行

string类的行输入：getline(cin,string类名)

异常情况：读取空行如何处理

getline是从上次结束读取的地方继续读，而get(xx,xx)则是插入失效位，后面的字符均无法读取

异常情况：输入字符串更长，两者都会把剩下的字符留在输入队列中，但是getline会额外插入失效位

失效位处理：cin.clear()可以清除输入队列，这样就能继续输入

## 数组和字符串混合输入

cin数字时会让换行符保留在输入队列中，此时用getline或者get读取会首先读到换行符，也就不会有需要输入的地方。

## 原始字符串字面量

用R来标识，字符串开头结尾用"（ 和）"来表示，中间符号任意，不会转义，若中间需要使用"（ ，则开头或结尾可以用" 任意字符(来代替，这样就不会混淆，结尾符号自然也要对称。

该字符可以跟u等前缀一起用

## 结构struct声明位置

可以在函数外部，也可以在函数内部声明

## 结构使用{ }初始化

=号可以省略

{}内未被初始化的字节用0代替

## 结构变量声明

可以在定义结构后马上声明，此时结构可无名称。

## 结构赋值

使用=号可以直接为结构中的每个成员赋值，即使成员是数组

## 结构中的位字段

使得创建与寄存器对应的数据结构变得方便

形式

```c++
struct demo{
	unsigned int sn : 4; //4 bits
	unsigned int : 4;
	bool good : 1;
};
```

操作与普通结构完全相同

## 共用体union

声明形式与定义变量与struct相似。

区别：

- 共用体长度为其最大成员的长度
- 所有成员共用同一个地址，因此每次只能存一个值
- 赋值时只会覆盖变量size的内存空间，因此多次给不同size变量赋值在内存中会混搭
- 初始化只能给一个变量初始化

好处：节省内存

## 枚举enum

可以代替const创建符号常量，用法也相当于符号常量

定义方式与使用结构相似

```
enum demo {e1,e2,e3};
```

定义了：1、一个枚举类型；2、3个符号常量

常量值：默认0开始，后面比前面一个大1。可以给任意中间的数赋值

用法：枚举最好只用于给枚举变量赋值。当然也可以利用自动转换或是强制转换用来计算。
枚举取值范围：枚举量上限为其最大值的最小的二次幂再减1，如最大值100，上限为127.枚举量下限同理，默认为0，-6的下线为-8.

枚举常量size：根据取值范围决定size

## 使用指针的危险

初始化：在使用解除引用运算符(*)之前，最好将指针初始化为一个确定的地址。否则未初始化的指针可能指向任何地方，会造成不可预知的bug。

显示的指定地址：必须使用强制类型转换(typeName *) 数字

## 运行时【动态】分配内存

malloc

new：new返回的是地址

```c++ 
typeName * point  = new typeName;
```

存储位置：常规变量存于栈区中，而new出来的存于堆区

c++中提供了检测并处理内存分配失败的工具

## 内存的释放delete

通常用于释放new出的内存空间

使用限制：不能对声明变量所得内存空间进行释放。

注意：使用时最好与new成对出现，否则会在同一个地址释放两次，抑或是造成内存泄漏，如果内存泄露严重程序可能会不断的寻找更多的内存。使用对象最好是初始化过的指针，否则会造成未知后果。

对空指针释放没有影响

## 内存泄漏

内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

解决方法：1、内存使用完毕后主动释放 2、智能指针

## 数组类型

静态数组：静态联编，编译时确定size，给数组分配内存，

动态数组：动态联编，运行时动态分配，应该用delete []释放

数组直接用=号传递的是地址

## 动态数组

分配内存形式，point会指向第一个元素

```c++
typeName * demo = new tyeName [num];
```

释放内存形式

```
delete [] listName;
```

与数组的区别：

- 无法用sizeof来判断动态数组大小
- 数组名的值不可修改为常量，而指针可以

指针与数组基本等价的原因在于指针运算和c++内部处理数组的方式相近。

数组名相当于第一个元素的地址，但使用sizeof的时候则为数组size。

## cout数组

给cout提供一个字符的地址，则它将一直输出直到空字符。

## 字符串地址

char数组、char指针、字符串常量都被解释为字符串的第一个字符的地址

## const指针

只允许访问不许修改

比如说常量的地址，就要加上const，但是指针可以改变指向

## 数组赋值

尽量用strcpy或strncpy而不是等号

## 引用成员的方法

对象用句点

指针因为不是对象，所以需要用箭头，或者是先解除引用再用点

## c++管理数据内存的方式

- 自动存储【栈】

函数内部定义的常规变量使用自动存储空间——自动变量

随着函数调用时产生，函数结束时消亡

占用的内存总是连续的

- 静态存储【栈-可能】

在整个程序执行期间都存在的存储方式。

两种静态方法：1、在函数外定义 2、在声明变量时用static

- 动态存储【堆】

利用new和delete动态分配内存，该内存池与静态和自动变量分开存放。声明周期不完全受程序或函数的生存时间控制。

占用的内存可能不是不连续的。

## 访问指针的格式

访问变量：*   /   [] 

访问成员：-> / .

## STL模板类

vector代替动态数组，参数只有类型，使用堆存储

```
vector<typeName> name (数量)；//数量可选择预定义，但是依旧是可以改变的
```

array代替定长数组，参数有类型+数量，使用栈存储

```
array<typeName,num> name;
```

使用数组的方式访问可能会导致越界错误，而两个模板类提供at(index)方法来访问，可以检查越界，但是运行的时间会更长。

array中的数量也必须为确定的值，不能是变量

## cin起始

从第一个非空白开始

## bool与整数类型转换

C++程序在需要整数值的地方将把true和false分别转换为1和0，而在需要bool值的地方将把0转换为false，非0转换为true

## cout输出bool值格式

使用cout类的setf方法，参数为ios_base::boolalpha或ios::boolalpha

## 副作用和顺序点

副作用指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；

顺序点是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估

完整的表达式：不是另一个更大表达式的子表达式

顺序点位置：分号；任意完整的表达式；逗号

## 递增/递减的前后缀格式比较

1. 加的时间不同，一个在上一个顺序点之后开始，一个在下一个顺序点前开始
2. 计算速度不同，后缀首先需要复制一个副本再+1，前缀是直接+，所以前缀更快。【内置类型变量无差别】
3. 优先级不同，后缀更优，先执行，但还是只能再下一个顺序点前+

## 作用域

{ }内部为一个域，若{} 内重定义，则在此域内新变量会覆盖旧变量

## 逗号表达式

优先级最低，从左到右计算，赋值为最右

## 字符串的比较

c风格的字符串数组

以‘\0’来标记末尾确定字符数量，且名为地址，直接用==判别是判断地址是否相同，用cstring中的strcmp(a，b)函数可以用来判别是否a>b，大于为正，小于为负，等于为0

c++的string类型

string是对象，而不是数组，且重载了关系运算符，因此可以直接使用关系运算符。string对象不以空字符来标记字符串末尾

## 延时循环

方法1：

使用计数循环来达成延迟的目的

方法2：

使用ctime中的clock()函数获得程序开始执行后所用的系统时间

常量CLOCKS_PER_SEC为每秒包含的系统时间单位

clock_t为clock所返回的时间类型，编译器会自动挑选转换为整数

```c++
#include<ctime>
clock_t time = clock();
```

## 类型别名

方法1：

#define aliasName typeName;

方法2：

typedef typeName aliasName;

能处理更复杂的类型

处理方法：

预处理器会将代码中的对应位置替换为定义的类型

```
//define问题
#define float_point float *;
float_point pa,pb;
//替换为
//float * pa,pb;

```

# 入口循环/出口循环

入口循环：

while(){

}

for(){}

出口循环

do{}while();

## 基于范围的for循环（C++11）

可用于数、容器类

格式

```c++
double prices[5] = {1,1,1,1,1};
for(double x : prices)
	cout<< x << std::endl;
for(double x : {1,1,1,1,1})
	cout<< x << std::endl;

```

若要修改其值可以使用引用

```c++
double prices[5] = {1,1,1,1,1};
for(double &x : prices)
    cout<< x << std::endl;
```

## 循环输入的文本方式

结束条件判别

1、需要指定哨兵：输入尾符号，用以判断输入是否结束了

2、也可以通过文件尾来判别：EOF，EOF不表示输入中的字符，而是指出没有字符

文件尾键盘模拟方式：ctrl+z或者ctrl+d

检测方法：cin检测到EOF时，会将eofbit和failbit都设置为1，cin将不读取输入，再次调用cin也不管用。可以通过成员函数eof()或fail()查看是否读取到了文件尾。

可以通过cin.clear()清除cind状态

3、还可以通过cin是否输入成功判断

cin.get()会返回一个cin对象，放在判断中，读取成功会自动转化为true，并且还能检测其他的失败原因

1、使用cin

每次读取一个char字符，cin在读取基本类型时会自动跳过空格和换行符

每次输入都会放在缓冲中，按下回车才会被输入程序里 

2、cin.get(char)

读取任意字符【除了EOF】，并赋值给char。

该函数背后参数是引用类型，所以能改变其值。

get()带参数的：返回的是cin对象

读取到EOF时，可以用if(cin)判断是否结束或者时cin.fail()

3、cin.get()

get()不带参数的：返回的是字符，字符编码作为int返回，当读取到EOF时，返回EOF常量，值为-1

同时可以使用cout.put(ch)来显示字符

用来代替getchar与putchar