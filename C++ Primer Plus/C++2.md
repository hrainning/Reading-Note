## c++函数返回值限制

不能直接返回数组

## 函数原型的作用

原型描述了函数的接口，包括了返回类型，参数类型与数量【可以不指定变量名】

1. 确保编译器正确处理函数返回值
2. 编译器用来检查参数数目
3. 编译器检查使用的参数类型是否正确，允许时可以自动转换

在编译阶段进行的原型化被称为静态类型检查

## 编译器不全文件查找的原因

1. 效率不高，搜索时需要停止main
2. 函数不在本文件中

## 函数的参数

形参parameter：接收值的变量

实参argument：传递的值

## 数组作为参数

好处：减少拷贝的系统开销

坏处：增加破坏数据的风险

参数形式1：数组起点 + 数组数量

参数形式2：数组起点+数组结尾的后一个位置

## cin可以用来检测输入类型是否正确

```c++
int temp;
cin>>temp;//输入q
if(!cin){
	cout<<"erro";
}
```

输入类型不对，cin返回的是false，且设置错误条件禁止继续输入，可以用cin.clear()来清除

## 数组名相较于指针的特殊性

1. 数组声明使用数组名来标记存储位置
2. sizeof能返回整个数组的长度
3. 对数组名使用&返回的是整个数组的地址，+1加的是数组长度

## 指针与const

- 常量只能被const指针指
- 指向const的指针无法改变指向的变量的值[const typename]
- 若数据类型非指针，则可以将地址赋给const指针
- 若数据类型为指针，则const均可接收，而非const只能接收非const

形参使用const好处：1、避免无意中修改 2、既能处理const也能处理非const的实参

const限定的是其后面的

```
const int * demo; // 限定int不可改
int * const demo; //限定demo指向不可改
const int * const demo;//都不可改
```

## 二维数组作为形参

必须指定列数

格式1：

```c++
void demo( type dd[][num]);
```

格式2：

```c++
void demo( type (*dd)[num]) //[]优先级比*高，若不加括号则变为dd[],内容为type *，指向的是变量而非数组，我们要的是(*)[]指向数组的指针，每加1就是加一个数组的距离。
```

使用1：

```
dd[r][c]
```

使用2:

```
*(*(dd+r) + c)
```

形参其实也可以用一维指针来担当,使用的时候就一次+法就好

```
void demo( type * d);
```

## char数组与字符串的区别

char数组内值没有'\0'，而字符串末尾为'\0'

## C风格的字符串作为形参

C风格的字符串表达方法：

- char数组
- 字符串常量
- char指针

均返回地址，所以只需要用char *或char []作为形参即可

## 结构与数组的区别

1. 数据类型多样
2. 像基本变量一样，赋值操作可以用=号，且是值传递
3. 结构名只是结构的名称而非地址

## 结构作为参数

结构作为参数会复制结构的值【与基本类型相同】，这样会增加内存要求，因此往往使用地址传递的方式。

形参形式有三种：

- 值传递【普通就是值传递】
- 按引用传递
- 指针传递【&获取地址】

对象用法与结构相似【如string对象、模板类】

## 函数指针

使用的前提：

1. 获取函数的地址：函数名即函数地址

2. 声明一个函数指针：声明方式 【returnType (*name)  (parameterType)】 ，指针的参数和返回类型必须和函数一致。name就是函数指针的名，用()中的内容代替函数原型比较方便不容易错

   ```
   double (*name)(int);//指向函数的的指针
   double * name (int);//返回指针的函数
   ```

3. 使用函数指针来调用函数

   ```
   //两种用法,假设pf是指针
   x = pf(1); //可
   x = (*pf)(1); //可
   ```

## auto用法限制

不能用于初始化列表既{ }

## 指向数组的指针

```c++
typeName (*pName)[num] ;
```

## 输入数字并能判断是否非法

while(cin>>number){

}