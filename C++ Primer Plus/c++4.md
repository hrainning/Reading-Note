## oop特征

- 抽象：将问题的本质特征抽象出来，并根据特征来描述解决方案
- 封装：将实现细节放在一起并将它们与抽象分开被称为封装。
- 多态
- 继承

## 面向过程编程步骤

首先考虑要遵循的步骤，然后考虑如何表示这些数据

## 面向对象编程步骤

首先从用户的角度考虑对象——描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建出程序。

## 声明解决的问题

1. 说明变量的值
2. 说明变量的类型
3. 说明变量占用内存大小

## 指定类型完成的任务

- 决定数据对象需要的内存数量；
- 决定如何解释内存中的位（long和float在内存中占用的位数相同，但将它们转换为数值的方法不同）；
- 决定可使用数据对象执行的操作或方法。

## 定义类

- 类的声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口。
- 类方法定义：描述如何实现类成员函数。

类声明提供了类的蓝图，而方法定义则提供了细节。

接口作用：实现两个系统/对象间的交互

类名首字母大写

通常，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。使用了#ifndef等来访问多次包含同一个文件。

通常private中的函数在类声明中定义，其他函数都在外边定义

## class与struct区别

C++对结构进行了扩展，使之具有与类相同的特性。它们之间唯一的区别是，结构的默认访问类型是public，而类为private。C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象

## 类的内联函数[inline]

其定义位于类声明中的函数都将自动成为内联函数，类声明常将短小的成员函数作为内联函数。如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此，只需在类实现部分中定义函数时使用inline限定符即可。内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是：将内联定义放在定义类的头文件中（有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件）。根据改写规则（rewrite rule），在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数。

## 对象的存储管理

所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。

## 创建类对象的方法

1. 声明类变量
2. 用new为类对象分配存储空间
3. 作为返回值或参数
4. 用=号赋值

初始化对象，cin和cout识别对象，相似的类对象之间自动类型转换。

## 构造函数

类构造函数，专门用于构造新对象、将值赋给它们的数据成员。每次创建类对象时，将自动调用构造函数。

注意：构造函数的参数不要与类成员名称相同，否则可能会造成混乱

```c++
//使用构造函数的方法
//定义一个构造函数
class demo
{
    public: 
    demo(){};//默认构造函数，当类中无别的构造函数时，编译器会提供
    ~demo();
    demo(int p){};
}
//声明类对象
demo d1;//自动调用空参数列表的构造函数【默认构造函数】
demo d2(1);//隐式调用构造函数
demo d3 = demo(1);//显式调用构造函数，该形式的初始化可能用临时对象也可能不用
demo *d4 = new demo(1); //使用new时调用
demo *d5 = new demo; //使用new时调用默认构造函数
//若只有一个参数的构造函数可以用值来初始化
demo d9 = value;
//C++11新特性
demo d6 =  {1}; //需要有构造函数一一对应
demo *d8 =  new demo{1}; //需要有构造函数一一对应
demo d7{}; //匹配默认构造函数
```

默认构造函数：在未提供显式初始值时，用来创建对象的构造函数。

何时声明：当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。

## 析构函数

每个类都只能有一个析构函数，对象过期时，程序将自动调用。如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。

对象过期时间

- 静态存储对象：程序结束时过期
- 自动存储类对象：执行完代码块后过期
- 动态存储对象：使用delete或程序结束时过期
- 临时对象：对象使用完毕后调用

作用：如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。

析构顺序：由于这种自动变量被放在栈中，因此最后创建的对象将最先被删除，最先创建的对象将最后被删除

## const对象

```c++
//类student
const student demo = student();
//其函数必须用const声明与定义，否则无法确保是否会修改this。
void show() const;
void stock::show() const{}
//类方法中，const放在函数后面，说明这个函数不会该改变对象的值，const放在前面，说明这个方法返回的是const的变量或对象
```

## this指针

每个成员函数（包括构造函数和析构函数）都有一个this指针，指向用来调用成员函数的对象。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。

## 对象数组

```c++
//定义形式
class student;
student demo[4];//默认调用构造函数
//使用花括号显示指定使用哪一种构造函数，剩下的1个自动调用默认构造函数
student demo[3] = {student(),
                  student()}
```

初始化对象数组的方案

首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。

## 类的作用域

在类中定义的名称（如类数据成员名和类成员函数名）

的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必须通过对象。

## 在类内使用符号常量

```c++
class demo
{
    const int Month = 1;  //定义常量，但需要对象才能用
    double cost[Month];//不可取，类在未创建对象时没有用于存储值的空间，因此还无法使用
    //作用域均在类中
    //非要使用的解决方法
    //方法1：使用枚举
    enum{Month};//类中使用枚举并不会创建数据成员，只充当一个符号名称，编译时遇到它会直接替换。
    //方法2：使用static + const修饰成员变量
    static const int Month = 1;//与其他静态变量存在一起，而不与对象放在一起。
}
```

## 作用域内枚举

给枚举添加作用域，防止多个同名枚举冲突

```c++
//c++11
//定义方法
enum class egg{i,j};
enum struct get{i,j};
//此类枚举不支持隐式转换类型，必须显式指定
std::cout<<int(egg::i);
//使用的时候必须要加上域限定
egg::i;
get::i;
//可以显式的指定底层存储类型,默认int
//常规枚举也可以这样使用，默认类型随实现而异
enum class : short egg{i,j};
enum  : short get{i,j};
```



## 类的内联方法

其定义位于类声明中的函数都将自动成为内联函数，不论是public还是private

## 类的设计理念

C++试图让用户定义的类型尽可能与标准类型类似

类是用户定义的类型的定义。类声明指定了数据将如何存储，同时指定了用来访问和操纵这些数据的方法（类成员函数）。

## 重载运算符

需要使用：运算符函数的特殊函数形式

```c++
opratetorop();//后面的op为算符
```

运算符-运算符函数

```c++
int a = sid + sara;
//等价于
int a = sid.operator+(sara);
//因此只要实现了opratetorop();就当相当于重载了op运算符
```

重载符的限制：

1. 操作数中至少有一个是自定义类型

2. 使用时不能违反原先的语法规则

3. 不能修改运算符的优先级

4. 不能创建新的符号

5. 不能重载这些符号

   ```
   sizeof:sizeof运算符
   .：成员运算符
   .*：成员指针运算符
   ::：作用域解析运算符
   ?:：三目条件运算符
   typeid：一个RTT运算符
   const_cast：强制类型转换运算符
   dynamic_cast：强制类型转换运算符
   reinterpret_cast：强制类型转换运算符
   static_cast：强制类型转换运算符
   ```

6. 部分只能通过成员函数重载的运算符

   ```
   = :赋值运算符
   () ：函数调用运算符
   [] :下标运算符
   -> ：通过指针访问类成员的运算符
   ```

7. 其余都可非成员函数重载

重载实例

```c++
class box;
//成员函数中
box operator+(const box&);
//非成员函数中
box operator+(const box&,const box&);
```

在定义运算符时，必须选择其中的一种格式，而不能同时选择这两种格式。因为这两种格式都与同一个表达式匹配，同时定义这两种格式将被视为二义性错误，导致编译错误。

## 函数返回值变量

不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。 

## 友元

- 友元函数
- 友元类
- 友元成员函数

## 友元函数

需求：某些函数需要使用类中的私有数据，因此需要引入友元函数以获取跟类的成员函数相同的访问权限。通常用于对运算符的重载上、

做法：定义函数域声明函数的方式与常规函数无差别，唯一的区别在于需要额外在类中再次声明，且声明前+friend关键词。

是否有悖于oop：从概念上来将，应将友元函数看作类的扩展接口的组成部分。只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了哪些函数可以访问私有数据。总之，类方法和友元只是表达类接口的两种不同机制。但是记住，友元函数不是成员函数。

friend添加时机：只有在类声明中的原型中才能使用friend关键字。除非函数定义也是原型，否则不能在函数定义中使用该关键字。 

## 重载<<运算符

方法1：直接将一个新的函数运算符定义加到ostream类声明中。不建议使用

方法2：通过友元函数定义

```c++
class demo
{
    int a,b;
public:freind ostream & operator<<(ostream &,const demo &);
}
ostream & operator<<(ostream &os,const demo &t)
{
    os<<t.a<<t.b;
    return os;
}
//os中不用友元的原因，友元的目的是使用其私有变量，而输出无需使用ostream的私有变量
//不用成员函数的原因，考虑使用顺序的问题，用成员函数则用起来变成[demo]<<[ostream]
//除了cout还有cerr也是ostream，不过通常用来输出错误
```

## C++三角函数

c++的内置数学函数在使用角度时以弧度为单位，

## c++随机数

标准ANSI C库[stdlib.h或cstdlib]中有一个rand()函数，用来返回随机数。

rand( )：

返回一个从0到某个值（取决于实现）之间的随机整数。该程序使用求模操作数来获得一个0～359的角度值。rand( )函数将一种算法用于一个初始种子值来获得随机数，该随机值将用作下一次函数调用的种子）依此类推。这些数实际上是伪随机数，因为10次连续的调用通常将生成10个同样的随机数（具体值取决于实现）。

srand( )

允许覆盖默认的种子值，重新启动另一个随机数序列。该程序使用time（0）的返回值来设置种子。time（0）函数返回当前时间，通常为从某一个日期开始的秒数。

```c++
srand(time(0));//只需要用一次就好
rand();
```

## 类的自动转换

- 内置类型转换

将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。

在无法自动转换时，可以使用强制类型转换

- 用户自定义类转换

标准类型变量->自定义类：

当存在一个单参数或只有一个参数没赋默认值的构造函数时就可以。这种函数叫**转换构造函数**。

```c++
class my
{
public: my(double j){};
}
my mt = 19.5;//将double转换为了my类。
//过程：先创建一个临时变量，再将值赋给mt对象。
//属于隐式转换
//在此构造函数前 + explicit 即可关闭这种特性，但依旧可以显示转换，用法与标准类型一致
```

只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则也可以用于隐式转换。 

隐式转换场景

- 将自定义类对象初始化为内置类型值时。
- 将内置类型值值赋给自定义类对象时。
- 将内置类型值值传递给接受自定义类参数的函数时。
- 返回值被声明为自定义类的函数试图返回内置类型值值时。
- 在上述任意一种情况下，使用可转换为内置类型的内置类型时。【如int 可以转化为double时，先转换标准类型，再用标准类型转化为自定义类型】【出现多个可转化则有二义性】

自定义类-》标准内置类型

使用**转换函数**operator typeName();

使用限制

- 转换函数必须是类方法【需要的自定义类中】
- 转换函数不能指定返回类型【返回的是typeName】
- 转换函数不能有参数

```c++
class demo
{
    int a;
public:
    //需要转化为int，const可以去掉
    operator int() const{
        return a;
    }
    //同样为了不必要的麻烦，c++11，可以规定只用显式，再函数前+explicit
}
{
    demo test;
    //与正常强制转化用法相同，若存在多种转换函数，则不能隐式转换，因为有二义性，否则可以
    cour<<int(demo);
}
```

自定义类《—》标准内置类型

可以用函数来解决

## 重载运算符经验

1. 加法定义为友元可以让程序更容易适应自动类型转换。原因在于，两个操作数都成为函数参数，因此与函数原型匹配

## 友元函数与成员函数区别

1. 组织：成员函数是类定义的一部分，友元不是
2. 调用：成员需要对象调用，友元可以直接使用
3. 数据：成员可以隐式访问调用对象的成员，友元需要用参数中的对象来访问成员数据。