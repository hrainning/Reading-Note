

## 类中动态控制内存的问题

若对象中有用new来分配内存空间，则析构函数必须包含delete，否则当对象过期时，对象本身占用内存会被释放，而成员指针指向的new却无法释放

## 静态类成员

静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员，

不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。您可以使用这种格式来创建对象，从而分配和初始化内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。

```c++
class demo{
    static int a;
}
int demo::a = 1;
```

初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。

对于不能在类声明中初始化静态数据成员的一种例外情况（见第10章）是，静态数据成员为整型或枚举型const。

## C++自动提供的成员函数

- 默认构造函数，如果没有定义构造函数；
- 默认析构函数，如果没有定义；
- 复制构造函数，如果没有定义；
- 赋值运算符，如果没有定义；
- 地址运算符，如果没有定义。
- 移动构造函数 [c++11]
- 移动赋值运算符[c++11]

```c++
//当使用一个对象来初始化另一个对象时，编译器的处理
class demo;
demo test2;
demo test1 = test2;//这种方式调用的是复制构造函数
//等价于
demo test1 = demo(test2);//复制构造函数
//复制构造函数原型
demo(const demo &);
```

## 默认构造函数

如果没有提供任何构造函数，C++将创建默认构造函数，创建对象时总是会调用构造函数【不一定是默认】如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时不显式地对它进行初始化，则必须显式地定义默认构造函数。带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。但只能有一个默认构造函数。

## 复制构造函数

复制构造函数用于将一个对象复制到**新创建**的对象中。也就是说，它用于**初始化过程中**（包括按值传递参数），而不是常规的赋值过程中。

```c++
//原型
class_name(const class_name &);
```

调用时机

新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。每当程序生成了对象副本时，编译器都将使用复制构造函数。无论是哪种编译器，函数中，当按值传递和返回对象时，都将调用复制构造函数。

```c++
class demo;
demo test;
//4种使用情形
demo test1(test);
demo test2 = test;
demo test3 = demo(test);
demo *test4 = new demo(test);
//中间两种可能会直接用复制构造函数创建test2和test3，也可能先用复制构造函数生成临时对象，然后再赋值给test2,test3，这取决于具体实现。
```

由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。

复制构造函数功能：默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。【指针变量值为地址噢】

浅复制可能的后果：由于浅复制只是简单的复制变量内容，当成员中包含指针变量，则会使得两个对象的成员均指向同一个地址，不论是析构时的delete还是调用函数修改都会造成严重的后果。

浅复制解决方法：在复制构造函数中定义深度复制，深度复制会复制对象成员中指针指向的数据，挖掘指针引用的结构，使得两个对象不会相互影响。

## 赋值运算符

赋值时，必定会用赋值运算符，但初始化时，虽然使用=运算符但也不一定调用赋值运算符。值操作并不创建新的对象

```c++
//使用=运算符但也不一定调用赋值运算符-例子
class demo;
demo tes1;
demo test2 = test1;
demo test2 = demo(test1);
//可能是先生成临时变量，再用赋值，也可能是直接用它的值来创建
```

与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。

赋值运算避免浅复制：

- 由于目标对象可能引用了以前分配的数据，所以函数应使用delete[ ]来释放这些数据。
- 函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。
- 函数返回一个指向调用对象的引用。

步骤:

1. 代码首先检查自我复制，这是通过查看赋值运算符右边的地址（&s）是否与接收对象（this）的地址相同来完成的。如果相同，程序将返回*this，然后结束。
2. 如果地址不同，函数将释放str指向的内存，这是因为稍后将把一个新字符串的地址赋给str。如果不首先使用delete运算符，则上述字符串将保留在内存中。由于程序中不再包含指向该字符串的指针，因此这些内存被浪费掉。
3. 接下来的操作与复制构造函数相似，即为新字符串分配足够的内存空间，然后将赋值运算符右边的对象中的字符串复制到新的内存单元中。

重载常用格式

```c++
c_name & c_name::operator=(const c_name & cn)
{
    if(this == &cn)
        return *this;
    delete [] c_pointer;
    c_pointer = new type_name[size];
   	//复制指针内容以及变量内容
   	return *this;
}
```

class_name & class_name::operator=(cont class_name &)

若数据成员中包含对象，则默认的赋值运算符会使用成员类型定义的复制构造函数和赋值运算符。

## 构造函数使用new原则

- 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。
- new和delete必须相互兼容。new对应于delete，new[ ]对应于delete[ ]。否则delete结果是不确定的。
- 如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空（0或C++11中的nullptr），这是因为delete（无论是带中括号还是不带中括号）可以用于空指针。
- 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。还应该更新所有受影响的静态类成员。
- 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。该方法应完成这些操作：检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用。

## delete

对不是使用new初始化的指针使用delete时，结果将是不确定的，并可能是有害的。

## 0的含义

在C++98中，字面值0有两个含义：可以表示数字值零，也可以表示空指针

## 空指针的表示

C：(void *) 0  |   NULL | 0 

c++11: nullptr

空指针本身的内部表示可能不是0

## 成员函数的特征标

在重载时，C++将区分常量和非常量函数的特征标

const成员函数用于const的对象[无非const函数则风非const也用]

非const成员函数只用于非const

## 静态成员函数

声明时必须+static，独立定义时不许+。【常规函数都得+】

静态成员函数不属于任何一个对象，不能通过对象调用静态成员函数。可以用类名+作用域解析符来调用。

静态成员函数不能使用this，只能使用static数据成员。

## 空行

get读取的是'\0'，换行是'\n'

## 函数返回值为对象

- 返回指向对象的引用：常用于重载运算符和cout等，前者提高效率，后者必须这样做【ostream &，其没有共用的复制构造函数】。
- 返回指向对象的const引用：提高效率
- 返回const对象
- 返回对象：如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数。因此，当控制权回到调用函数时，引用指向的对象将不再存在。【返回值会用复制构造函数复制到寄存器中】

## 析构函数的调用

- 如果对象是动态变量，则当**执行完**定义该对象的程序块时，将调用该对象的析构函数。
- 如果对象是静态变量（外部、静态、静态外部或来自名称空间），则在**程序结束时**将调用对象的析构函数。
- 如果对象是用new创建的，则仅当您显式使用**delete**删除对象时，其析构函数才会被调用。

## 定位new运算符创建对象

**用法**与寻常变量相同

**定位new运算符**出的对象没有办法detele，因为定位new没有对应的delete来删除，因此最后删除时只能删除最初new分配的地址，从而造成无法调用析构函数。

这种问题的解决方案：

显式地为使用定位new运算符创建的对象调用析构函数。显式地调用析构函数时，必须指定要销毁的对象。可以用指针指向对象，调用其析构函数。对于使用定位new运算符创建的对象，应以与创建顺序相反的顺序进行删除。原因在于，晚创建的对象可能依赖于早创建的对象。另外，仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。

```c++
class demo;
char * buffer = new char [100];
demo *test = new (buffer) demo;
test->~demo();  // 先创建的后析构
delete [] buffer;//在最后释放
```

## 类中嵌套结构或类声明

在类声明中声明的结构、类或枚举被称为是被嵌套在类中，其作用域为整个类。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。如果声明是在类的私有部分进行的，则只能在这个类使用被声明的类型；如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型。

## 调用构造函数创建对象的流程

调用构造函数时，对象将在括号中的代码执行之前被创建既分配内存。然后，程序流程进入到括号中，使用常规的赋值方式将值存储到内存中。

## 纯const数据成员

对于**非静态const数据成员**，必须在执行到构造函数体之前，即创建对象时进行初始化。【因为是先分配内存，再赋值，const要求分配内存时就进行初始化】因此需要用成员初始化参数列表来为const完成赋值，该方法只能用于构造函数。【引用数据成员也得用这个来赋值，因为它也需要马上初始化】

**语法**

```c++
class classy
{
    const int  mem1,mem2 =1;
    int mem3;
public:
    classy(int n,int m);
};
//构造函数中的值会覆盖默认
classy:: classy(int n,int m):mem1(n),mem2(0),mem3(m+1)
{
    //若mem均为string则，在初始化参数列表中，在使用构造函数时是直接使用复制构造函数，若在函数体中，则是先调用默认构造函数给mem然后在用赋值运算符赋值。
    //mem3也可在这里赋值，而不是初始化参数列表
}
//普通变量也可以用这个形式来赋值
int ga = 1;
//等价
int ga(1);
```

## private使用小技巧

可以将构造函数、复制函数、赋值预算符重载放入其中，以禁止调用，减少不必要的麻烦。

## 抽象数据类型ADT

- stack
- list
- queue

stack栈的操作

1. 可创建空栈。
2. 可将数据项添加到堆顶（压入）。
3. 可从栈顶删除数据项（弹出）。
4. 可查看栈否填满。
5. 可查看栈是否为空。

queue队列操作

1. 队列存储有序的项目序列；
2. 队列所能容纳的项目数有一定的限制；
3. 应当能够创建空队列；
4. 应当能够检查队列是否为空；
5. 应当能够检查队列是否是满的；
6. 应当能够在队尾添加项目；
7. 应当能够从队首删除项目；
8. 应当能够确定队列中项目数。

## 隐式地址运算符

隐式地址运算符返回调用对象的地址（即this指针的值）

## 继承

目的：提供可重用的代码

功能：

1. 可以在已有类的基础上添加功能。
2. 可以给类添加数据。
3. 可以修改类方法的行为。

语法：

在类的定义中，类名的后面+：继承方式+基类

```c++
class son : public base1,public base2
{
    //添加自己的构造函数
    //添加额外的数据成员、成员函数
};
```

派生的效果：

1. 派生类对象存储了基类的数据成员（派生类继承了基类的实现）；
2. 派生类对象可以使用基类的方法（派生类继承了基类的接口）。

派生类别：

1. 公有派生
2. 私有派生
3. 保护派生

公有派生：

成员都保持原有状态，但基类的private不能直接访问。

私有派生：

成员都以private方式继承，依旧可以直接调用基类的public。数据成员最好都用私有。

保护派生：

基类public和protected都以protected方式继承，私有依旧为私有。protect可以在派生和友元直接使用，其余地方不行。



## 派生类的构造函数

派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。因此派生类构造函数必须使用基类构造函数。

创建派生类对象时，程序首先创建基类对象。这意味着基类对象应当在程序进入派生类构造函数之前被创建，因此需要用初始化列表完成。【初始化列表是在构造函数前使用】必须首先创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数。除非要使用默认构造函数，否则应显式调用正确的基类构造函数。

```c++
class base;
class gene: public base
{
int a1,b2,c3;
public:
    //在初始化列表中进行初始化
    //成员初始化列表只能用于构造函数。
   gene(int a,int b,int c,int par):base(par),a1(a)
   {
       b2 = b;
       c3 = c;
   }
}

```

要点：

- 首先创建基类对象；
- 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
- 派生类构造函数应初始化派生类新增的数据成员。

释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。

## 派生类

要使用派生类，程序必须要能够访问基类声明。可以放在同一个头文件中，也可以分开，放在一起更好。

使用基类中的方法，可以用域解析运算符。

不能继承构造函数、析构函数、赋值运算符和友元。

## 类型转化

基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。【单向转换】但是这种基类指针或引用也只能用基类的方法。

在指针与引用上来说，除了派生能给基类之外，一般不允许将一种类型给另一种类型。

向上强制转换：将派生类引用或指针转换为基类引用或指针，但是只能用基类有的，具有可传递性。

向下强制转换：将基类指针或引用转换为派生类指针或引用，只能用显示类型转换。

派生赋值给基类，值传递，只保留基类中有的。

注意：私有与保护继承不存在转换关系。

## 基类的初始化与赋值

除了原有的初始化方法，基类还可以用派生类对其初始化，调用默认复制构造函数，也可以用默认赋值运算符来修改基类的值。

## 类的关系

is-a：继承关系

has-a：用来充当数据成员

is-like-a：为两个类创建共有的基类

is-implemented-as-a：作为。。来实现，继承

uses-a：友元函数

## 多态公有继承

目的：希望同一个方法在派生类和基类中的行为是不同的，方法的行为取决于调用该方法的对象。

实现方式：

1. 派生类重定义
2. 虚方法【虚函数】

两者区别主要在当引用类型为基类时，一个根据引用类型来决定调用的函数，一个根据引用的对象类型来决定。

当继承方式为private或protected，基类

## 虚函数

定义：在类声明方法前+virtual，定义时不用。

虚函数的调用：

如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。

```c++
//base:demo1  derive:demo2
demo1 & d = new demo2();//指针也行
d.func();//若func不是虚函数，则用的是demo1中定义的方法，若func是虚函数，则用的是demo2类型对象的方法
```

经常在基类中将派生类会重新定义的方法声明为虚方法。【不重载的也可，但是代价高】方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。通常显示定义。

工作原理：主要是由编译器决定。通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表。虚函数表中存储了为类对象进行声明的虚函数的地址。

## 使用虚函数的代价

- 每个对象都将增大，增大量为存储地址【指向虚函数表的指针】的空间
- 每个类，编译器都创建一个虚函数表【数组】
- 每个函数调用都需要有到表中查找地址的操作

## 虚析构函数

基类声明了一个虚析构函数。与虚函数相同，都是为了确保当引用为基类而指向为派生类时能调用派生类的函数。当对象过期时，就能先调用派生析构，再调用基类析构。确保释放派生对象时，按正确的顺序调用析构函数。通常基类析构都有virtual。

## 静态联编和动态联编

当程序调用函数时，编译器负责制定调用哪个可执行代码块。

函数名联编：将源代码中的函数调用解释为执行特定的函数代码块。c++由于重载与虚函数比c更难实现。

静态联编：在编译过程中进行联编，编译器对非虚方法使用静态联编。

动态联编：在程序运行时选择正确的代码，编译器生成的代码将在程序执行时，通常用于虚函数。

两种联编的效率：动态联编需要额外的跟踪基类指针或引用，增大了处理开销。因此静态联编效率更高。C++的指导原则之一是，不要为不使用的特性付出代价（内存或者处理时间）。仅当程序设计确实需要虚函数时，才使用它们。

## 使用虚函数的注意事项

- 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。
- 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。
- 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。
- 构造函数不能为虚，派生肯定不会重载构造函数。
- 基类的析构函数应当是虚函数，保证能按序释放。
- 友元不能为虚，因为友元不是类成员，只有成员函数才能为虚。
- 如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本。
- 虚重定义继承方法【与基类中的特征标或返回值不同】会隐藏所有同名基类函数【与重载不同】，即使特征标不同，派生类也不会生成多个重载版本。因此，若需要重定义继承的方法，需要保持原型一致，除了返回值是基类引用或指针可以改为指向派生类的，否则均会隐藏。若非要重载，则应该在派生类中重定义所有的基类版本。

## ABC抽象类

抽象类的特征：含有纯虚函数，派生出的具体类必须实现这个虚函数。迫使派生类遵循ABC设置的接口规则。抽象类无法创建对象，只有其派生的具体类可以。

纯虚函数只需要在虚函数声明的后面加上= 0。即使已经定义了也可以加。可以加在析构函数上。

设计思想：只将那些不会用作基类的类设计为具体的类。

## string类

string类有一个将const char *作为参数的构造函数，使用C-风格字符串初始化string对象时，将自动调用这个构造函数。

## 继承和动态内存分配

构造函数必须在初始化列表中使用基类的构造函数，否则会调用基类的默认构造函数构造基类部分，其他考虑是否需要重写析构函数，默认复制函数，默认赋值运算符

- 派生类中没有指针

都不需要重写，析构函数会自动调用基类的析构函数；复制构造函数中，会自己使用对应数据结构的复制构造函数；赋值运算符同理。

- 派生类中存在指针

必须为派生类定义显式析构函数、复制构造函数和赋值运算符。

析构函数：由于析构函数会自动调用基类析构，所以只需要清理自己新产生的空间即可。

复制构造函数：除了要定义自己的new，还需要在初始化参数列表中调用基类的复制构造函数，参数可以用派生类的复制构造函数的形参，反正可以引用的。

复制运算符：需要显式的使用赋值运算符，需要用函数表示法base::operator=()函数来调用，若用this则会无限递归。

自动的默认构造函数：自动生成的默认构造函数会调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。

## 继承中的友元函数

若派生类中的友元函数需要使用基类中的数据成员，则必须也为基类定义友元函数，通过内置基类对应的友元函数达到访问基类数据成员的目的。若友元函数的名称相同，由于友元函数不属于类，因此无法通过域解析运算符来指定使用哪一个友元函数，但是可以用强制类型转换来达到目的。

## 类型转换的赋值运算符

方法1：

显示定义形参为需要的类型的赋值运算符以满足要求。这种方法运行速度块，但所需代码多。

方法2：

使用转换函数，这种方法可能导致编译器出错。

## 函数形参为引用好处

1. 可以提高效率
2. 可以使用虚函数

## 赋值运算符

赋值运算符不可继承：特征标随类型而异

## 公有派生使用基类的方法

- 继承：未重定义的基类方法
- 调用：未在成员初始化列表中定义的构造函数，自动调用基类的默认构造函数；可以作用域解析运算符来调用公有和保护的基类方法；用强制类型转化为基类引用或者指针调用基类的友元函数。