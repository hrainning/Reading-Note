## 友元

只能由类决定谁是他的朋友，因此不与面向对象的思想相悖。

- 友元函数
- 友元类
- 友元成员函数

## 友元类

友元类的所有方法都可以访问原始类的私有成员和保护成员。

友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。

```c++
freind class demo;//声明为友元，同时也指出他是一个类，因此不用向前声明
```

## 友元成员函数

仅让特定的类成员成为另一个类的友元。必须要注意声明和定义的顺序。需要向前声明。

```c++
//顺序必须为
class TV;
class remote{..};//其中有一个TV的友元类成员
class TV{..};//当中说明remote里的成员函数为友元
//为了避免remote中的友元调用TV中的函数所造成的未定义情况，将友元放在TV后面定义，就可以保证看见了TV的方法的声明
void remote::func(){..};//可以在前面+inline让他依旧可以是内联
```

## 内联

内联函数的链接性是内部的，这意味着函数定义必须在使用函数的文件中。

## 嵌套类

嵌套与包含不同，包含是直接将类对象作为另一个类的成员，嵌套是在类内再定义一个类型，并且能在类内使用。

作用域：

- 私有部分声明：只有本类定义的后方知道
- 保护部分声明：派生类可见，外部世界则不行
- 公有部分声明：本类、派生、外部都可以用，外界用的时候需要加类限定符【作用域解析符】。

访问权限：

通常嵌套类中的成员都放在公有部分，以便外层类来使用，但外层类则将其丢在私有，防止外界访问。

## 异常

C++异常的主要目的是为设计容错程序提供语言级支持，即异常使得在程序设计中包含错误处理功能更容易，以免事后采取一些严格的错误处理方式。异常的灵活性和相对方便性激励着程序员在条件允许的情况下在程序设计中加入错误处理功能。总之，异常是这样一种特性：类似于类，可以改变您的编程方式。

当除法中出现被零除的情况，值被设置为表示无穷大的浮点值来处理，cout输出为Inf、inf、INF等。也可能会导致程序崩溃。

异常处理方法：

- 规则检测，若会有问题则调用函数终止

abort()

头文件：cstdlib或stdlib.h

作用：其典型实现是向标准错误流（即cerr使用的错误流）发送消息abnormal program termination（程序异常终止），然后终止程序。它还返回一个随实现而异的值告诉操作系统（如果程序是由另一个程序调用的，则告诉父进程），处理失败。abort( )是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。

exit(可填入状态码)

作用：刷新文件缓冲区，程序立即终止，但不显示消息，遇到自动变量会释放，遇到自动对象也会调用析构函数

- 规则检测，值可以用指针或引用传递，若有问题输出提示，然后继续
- 使用全局变量记录规则判断的结果是否异常，调用程序可以检查它
- 使用异常机制来处理错误

## 异常机制

作用：提供将控制权从程序的一个部分传递到另一个部分的途径。

组成：

- 引发异常：throw
- 使用处理程序捕获异常：catch
- 使用try块：标识可能出现问题的块

```c++
main()
{
    try{
        test();//执行可能出现问题的函数
    }
    catch(与thorw相匹配的类型)//可以有多个，catch块的排列顺序应该与派生顺序相反
        //catch(...)可以捕获任何异常
    {
        //catch中再throw可以把这个异常再往上抛
    }
    //若异常最终没有找到try与匹配的catch则会自动调用abort()
}
int test()
{
    throw "xxx";//终止函数，令程序沿函数调用序列后退，直到找到try与对应catch，可以有多种异常类型
}
```

## 将对象用作异常类型

传递对象的好处：

可以使用不同的异常类型来区分不同的函数在不同情况下引发的异常。另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。同时，catch块可以根据这些信息来决定采取什么样的措施。

## 异常规范

原则上，异常规范应包含函数调用的其他函数引发的异常。

**C++98：**

在函数声明和定义后+throw(可有参);

作用：告诉用户可能需要使用try块。并且让编译器添加执行运行阶段检查的代码，检查是否违反了异常规范，既出现的错误要在规范中说明。

评价：比较难检查，检查的函数的调用函数可能会有异常，且库更新后可能会引发异常，最好不用

**C++11**

在函数声明后+noexcept

作用：指出函数不会引发异常

评价：最好不要使用它（至少在大多数情况下如此）；而有些人认为引入这个新关键字很有必要，理由是知道函数不会引发异常有助于编译器优化代码，相当于给了个承诺。

**判断操作数是否异常**

运算符noexcept()

作用：判断操作数是否有异常

## 栈解退

C++通常是如何处理函数调用和返回的：

C++通常通过将信息放在栈（参见第9章）中来处理函数调用。具体地说，程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到栈中，依此类推。当函数结束时，程序流程将跳到该函数被调用时存储的地址处，同时栈顶的元素被释放。因此，函数通常都返回到调用它的函数，依此类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数（如果有的话）将被调用。

栈解退：异常后不断释放栈。直到找到第一个位于try中的地址，然后控制权交给异常处理程序。程序进行栈解退以回到能够捕获异常的地方时，将释放栈中的自动存储型变量。如果变量是类对象，将为该对象调用析构函数。

## throw-catch机制与return机制

区别1：return会一个一个慢慢return，而throw是一步到位。函数fun( )中的返回语句将控制权返回到调用fun( )的函数，但throw语句将控制权向上返回到第一个这样的函数：包含能够捕获相应异常的try-catch组合。

区别2：引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。

## 引用的效用

1、避免创建副本提高效率

2、基类引用可以执行派生类对象

## exception类

头文件：exception或exception.h或except.h

有一个名为what( )的虚拟成员函数，它返回一个字符串，该字符串的特征随实现而异。可以在从exception派生而来的类中重新定义它。

```c++
const char * what() {..}
//捕获时使用
catch(std::exception & e)
{
    cout<< e.what()<<endl;
}
```

exception派生类：

stdexcept头文件

- logic_error：描述逻辑错误
- runtime_error：运行期间发生但难以预见、防范

logic_error派生类：

- domain_error:定义域错误
- invalid_argument：意料外的值
- length_error：长度过长
- out_of_bounds：索引错误

runtime_error派生类：

- range_error：不在允许的范围内
- overflow_error：上溢
- underflow_error：下溢

一般而言，logic_error系列异常表明存在可以通过编程修复的问题，而runtime_error系列异常表明存在无法避免的问题。

## new的异常

C++最新的处理方法是，让new引发bad_alloc异常，new中包含了bad_alloc类的声明。以前是返回空指针，所以不处理异常也能运行。

还可以设置new不发出异常

```c++
int * pi = new (std::nothrow) int;
```

## 异常问题

1. 意外异常：出现的异常不在异常规范列表中。
2. 未捕获异常：异常不在函数中引发，没有捕获到。

都将导致程序终止。

未捕获异常不会导致程序立即终止，会先调用函数terminate(),默认情况，这个函数会调用abort()。可以用set_terminate(函数名)来修改这种行为，都是在exception中声明的。

发生意外异常时，程序调用unexcepted()，这个函数会调用terminate()，行为与未捕获相同。也可以用 set_unexcepted（函数名）函数来修改行为，也是在exception中声明的。

set_unexcepted的处理方式：

1. 直接调用teminate或exit或abort终止
2. 再抛出一个异常，再在原来匹配的地方重匹配

再抛出的异常有三种：

- 与异常规范匹配：调用对应的catch
- 与异常规范不匹配：异常规范中包含bad_exception异常，则用bad_exception异常取代
- 与异常规范不匹配：异常规范中不包含bad_exception异常，则调用terminate()

仅使用throw，而不指定异常将导致重新引发原来的异常。

## 异常的注意事项

应在设计程序时就加入异常处理功能，而不是以后再添加。

缺点：

- 使用异常会增加程序代码，降低程序的运行速度。
- 异常规范不适用于模板，因为模板函数引发的异常可能随特定的具体化而异。
- 异常和动态内存分配并非总能协同工作。

在引发异常时，不能保证所有new出的内存块被释放，如动态数组，但是可以避免：

1. 可以在引发异常的函数中捕获该异常，在catch块中包含一些清理代码，然后重新引发异常
2. 使用智能指针模板

## RTTI

是运行阶段类型识别（Runtime Type Identification）的简称，目的是为程序在运行阶段确定对象的类型提供一种标准方式【基类指针指的什么类型】。

即使编译器支持RTTI，在默认情况下，它也可能关闭该特性。如果该特性被关闭，程序可能仍能够通过编译，但将出现运行阶段错误。

3个支持RTTTI的元素

- 如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该运算符返回0——空指针。
- typeid运算符返回一个指出对象的类型的值。
- type_info结构存储了有关特定类型的信息。

只能将RTTI用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生对象的地址赋给基类指针。

dynamic_cast：能够回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题

```c++
demo * pm = dynamic_cast<demo *>(pg);
//若可以安全的转换，则返回对象的地址，否则返回一个空指针
demo & pm = dynamic_cast<demo &>(pg);
//请求不成功，会引发bad_cast【typeinfo中定义】的异常

```

typeid运算符：确定两个对象是否为同种类型。

```c++
typeid(class1) == typeid(class2);
//参数可以是对象表达式也可以是类名
```

typeid运算符返回一个对type_info对象的引用，其中，type_info是在头文件typeinfo（以前为typeinfo.h）中定义的一个类。type_info类重载了= =和!=运算符，以便可以使用这些运算符来对类型进行比较。

如果pg是一个空指针，程序将引发bad_typeid异常。该异常类型是从exception类派生而来的，是在头文件typeinfo中声明的。

type_info类的实现随厂商而异，但包含一个name( )成员，该函数返回一个随实现而异的字符串：通常（但并非一定）是类的名称。它们都适用于dynamic_cast和virtual函数不能处理的情况。

## 类型转换符

更严格的限制允许的类型转换

- dynamic_cast
- const_cast；
- static_cast；
- reinterpret_cast

```c++
dynamci_cast <type-name> (expression)
const_cast <type-name> (expression)
static_cast <type-name> (expression)
dynamci_cast <type-name> (expression)
```

dynamic_cast：仅当被赋值对象是直接或间接基类的时候才可以赋值,使得能够在类层次结构中进行向上转换，否则返回空指针。

const_cast：const_cast运算符用于执行只有一种用途的类型转换，即改变值为const或volatile，除了const或volatile特征（有或无）可以不同外，type_name和expression的类型必须相同。

提供该运算符的原因是，有时候可能需要这样一个值，它在大多数时候是常量，而有时又是可以修改的。在这种情况下，可以将这个值声明为const，并在需要修改它的时候，使用const_cast。

对于指向const值的指针来说，即使使用了也无法改变其值。

static_cast：仅当type_name可被隐式转换为expression所属的类型或expression可被隐式转换为type_name所属的类型时，上述转换才是合法的，否则将出错。static_cast运算符允许向上转换和向下转换。static_cast运算符还允许枚举类型和整型之间以及数值类型之间的转换。

reinterpret_cast：用于天生危险的类型转换，可以从整型转换到地址。它不允许删除const。可以将指针类型转换为足以存储指针表示的整型，但不能将指针转换为更小的整型或浮点型。另一个限制是，不能将函数指针转换为数据指针，反之亦然。

在C++中，普通类型转换也受到限制，比如说地址转换为char就不行。

## string

头文件：string

c-风格字符串的操作库：string.h，cstring

string实际上是模板具体化basic_string< char>的一个typedef，同时省略了与内存管理相关的参数

成员

size_type：一个依赖于实现的整型

npos:字符串最大长度

函数

构造函数：7种

运算符重载-输入输出：

```c++
//c-风格字符串输入 [cin是调用对象]
cin>>info;
cin.getline(info,100);
cin.get(info,100);
//string的输入 [cin是参数]
//输入size会自动调整，但是要小于npos
cin>>stuff; //停止情况：1、空白字符停止，isspace()可以用来判断；2、分界符停止，丢弃
getline(cin,stuff);//停止情况：1、文件尾，eofbit被设置，fail与eof方法都为true；2、分界符，丢弃不存；3、数量超出最大，设置输入流failbit。
//getline可选参数
//末尾可以添加输入边界符
getline(cin,stuff,':');
//默认换行为分界符，若指定则非分界符
```

常规函数

size、length：字符数

find：搜索子字符串，没找到返回string::npos比最大的索引值大1

capacity：返回当前字符串的内存块大小，每次翻倍

reserve：请求内存块的最小长度

c_str：转化为c风格的字符串

## 智能指针

定义指针的对象，帮助管理动态内存分配。当智能指针过期时，其析构函数将使用delete来释放内存。因此，如果将new返回的地址赋给这些对象，将无需记住稍后释放这些内存：在智能指针过期时，这些内存将自动被释放。

new出的内存不释放原因：1、忘记delete 2、出现异常delete不执行

三种智能指针模板

- auto_ptr<>
- unique_ptr<>
- shared_ptr<>

头文件< memory >

```c++
auto_ptr<typename> pd(new typename);
unique_ptr<typename> pd(new typename(value));
shared_ptr<typename> pd(new typename);
//typename为要指向的类型，pd为指针，new typename返回指向的地址，可以在其中初始化
//普通指针类型转换时必须显式指定，因为构造函数中包含了explicit
shared_ptr<double> pd;
double * pp = new double;
pd = shared_ptr<double>(pp);
//注意不能创建非堆内存的指针
```

智能指针对象赋给另一个同类型的智能指针对象，但将引起一个问题：删除时会删除两次。

解决方法：

1. 重定义赋值运算符，进行深度复制
2. 限制所有权，只被一个智能指针拥有
3. 创建智能更高的指针，跟踪引用对象的指针数

限制所有权：auto_ptr与unique_ptr会在赋值的时候，将所有权转让出去，自己只剩空指针。

更高智能的指针：shared_ptr，共享时会计数，析构时会-1，当减到0才释放

auto与unique的区别：auto允许所有权转让后，留下一个空指针，而unique会报错。因此unique更优。

auto_ptr：new分配

shared_ptr：new分配

unique_ptr：new与new[]均可

函数：

move:强制将一个unique赋给另一个unique

选择：

需要共享的用shared，不需要的用unique，数组或者容器中的也可以用unique，unique作为形参必须用引用。

## 移动构造函数

构造函数string（string && str）【右值引用】类似于复制构造函数，导致新创建的string为str的副本。但与复制构造函数不同的是，它不保证将str视为const。编译器可使用它而不是复制构造函数，以优化性能。

复制构造和复制赋值以及移动构造和移动赋值之间的差别在于，复制操作保留源对象，而移动操作可修改源对象，还可能转让所有权，而不做任何复制。如果源对象是临时的，移动操作的效率将高于常规复制。

## 输入流

输入流对象有一个统计系统，用于跟踪流的错误状态。在这个系统中，检测到文件尾后将设置eofbit寄存器，检测到输入错误时将设置failbit寄存器，出现无法识别的故障（如硬盘故障）时将设置badbit寄存器，一切顺利时将设置goodbit寄存器。

## 异常规范

规范内容为空throw()，意味着不会引发异常

## STL标准模板库

容器是一个与数组类似的单元，可以存储若干个类型相同的值。

编程模式-泛型编程

与string类相似，各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存。默认使用allocator<T>类。这个类使用new和delete。

公用数据成员

通用方法：

- size：元素数目
- swap：一个或两个参数，交换容器的内容
- begin：返回指向第一个元素的迭代器
- end：返回一个标识超过容器末尾的迭代器
- rbegin：返回超尾的反向迭代器
- rend：返回指向第一个元素的反向迭代器
- cbegin：指向容器第一个元素的const迭代器
- cend：返回超尾值const迭代器
- for_each：三个参数，两个迭代器标识区间+1函数指针，区间内元素都使用这个函数
- random_shuffle：两个参数，标识迭代器区间，随机排列
- sort：两个或三个参数，标识迭代器区间，类必须实现了<运算符，三个参数最后一个可以指向要用来排序的函数指针
- copy：三个参数，标识迭代器范围，迭代器插入位置，将数据从一个容器复制到另一个容器，容器要够大，插入位置所用的迭代器不同会产生不一样的效果
- set_union：五个迭代器参数，前两个是第一个集合区间，接着又是一个区间，最后一个为输出迭代器。直接用一个迭代器接受会有问题-1、返回的是常量迭代器；2、与copy相似，可能没有足够大的空间，可以同insert_iterator来接收或是输出迭代器ostream_iterator可以避免这俩问题
- set_difference：五个参数迭代器，与setunion差不多
- lower_bound：1个键参数，返回第一个不小于参数的元素迭代器
- upper_bound：1个键参数，返回第一个大于参数的元素迭代器
- transform：与for_each相似，但是功能更加强大，阔以多个参数，阔以复制原地
- next_permutation：根据顺序，自小而大，自动提供唯一的排列组合

专用方法往往比通用方法效率高。

实现STL方法步骤：

1. 首先是处理容器的算法，应尽可能用通用的术语来表达算法，使之独立于数据类型和容器类型。
2. 为使通用算法能够适用于具体情况，应定义能够满足算法需求的迭代器，并把要求加到容器设计上。
3. 即基于算法的要求，设计基本迭代器的特征和容器特征。

指针满足所有迭代器的要求，因此也可以用指针来对基于指针的非STL容器进行操作，既可以用指针与迭代器混搭使用STL算法，如数组。

容器类型：

- deque-序列型
- list-序列型
- forward_list-序列型
- queue-序列型
- prioprity_queue-序列型
- vector-序列型
- stack-序列型
- map
- multimap
- map
- set
- multiset
- bitset

容器概念：描述了所有容器类都通用的元素，不使用真正的继承，指定了所有容器类都必须满足的要求。当容器过期时，存储在容器中的数据也将过期。

容器数据类型：必须是可复制构造和可赋值的，因此不是所有类型都可

STL方法：

- 容器的算法：独立于数据类型和容器类型
- 容器的迭代器：每个容器都有迭代器
- 特征：基于算法要求，设计容器与迭代器的特征

容器执行操作的复杂度：

- 编译时间：在编译时进行，时间0
- 固定时间：运行阶段执行，固定于对象中的元素
- 线性时间：时间与元素数目成正比

容器的改进：

1. 加入序列：数据有序
2. 加入关联：值与键关联在一起
3. 无序关联容器：与关联相似，差在无序存储上
4. 函数对象：像函数一样使用对象

## 迭代器

迭代器可以理解为一个广义的指针，通过迭代器能为访问不同的容器提供统一接口，每个容器类都有自己迭代器iterator。

特征：

- 应能够对迭代器执行解除引用的操作，以便能够访问它引用的值。
- 应能够将一个迭代器赋给另一个。即如果p和q都是迭代器，则应对表达式p=q进行定义。
- 应能够将一个迭代器与另一个进行比较，看它们是否相等。即如果p和q都是迭代器，则应对p= =q和p!=q进行定义。
- 应能够使用迭代器遍历容器中的所有元素，这可以通过为迭代器p定义++p和p++来实现。

类型：

- 输入迭代器：用来读取容器中的信息，单向，只++
- 输出迭代器：解除引用让程序能修改容器值，而不能读取，单向，只++
- 正向迭代器：正向迭代器只使用++运算符来遍历容器，所以它每次沿容器向前移动一个元素，与输入和输出迭代器不同的是，它总是按相同的顺序遍历一系列值。只++
- 双向迭代器：双向迭代器具有正向迭代器的所有特性，同时能双向遍历容器支持两种（前缀和后缀）递减运算符。
- 随机访问迭代器：要求能够直接跳到容器中的任何一个元素，这叫做随机访问。具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于对元素进行排序的关系运算符。

层次结构：

1. 输入、输出
2. 正向
3. 双向
4. 随机

在编写算法尽可能使用要求最低的迭代器，并让它适用于容器的最大区间。vector的是随机，list是双向的

```c++
#include<iterator>
//输出迭代
ostream_iterator<int,char> out_iter(cout," ");
//out_iter是一个接口，能用cout来显示信息，第一个模板参数为数据的类型，第二个模板参数为字符的类型，cout表示要使用的输出流，最后一个字符串表示每个数据项的分割符。
//使用
*out_iter++ = 15;
//15给指针指向，然后指针+1，15被发生到cout中，并为下一次输出做好了准备。
//也可以这样用
copy(dic.begin(),dic.end(),out_iter);
//直接匿名
copy(dic.begin(),dic.end(),ostream_iterator<int,char>(cout," "));
//输入的同理
copy(istream_iterator<int,char>(cin),istream_iterator<int,char>(),dic.begin());
//istream_iterator中的参数与输出一致，第一个为cin管理的输入流，第二个表示输入失败，可以用来表示文件尾，类型不匹配等
```

其他迭代器

- ostream_iterator：输出迭代
- istream_iterator：输入迭代
- reverse_iterator：递增将导致递减
- back_insert_iterator：插入容器尾部-vector
- front_insert_iterator：插入容器前端-queue
- insert_iterator：插入指定位置前

```c++
back_insert_iterator<vector <int> > back_iter(dics);
insert_iterator<vector <int> > back_iter(dics,dics.begin());
//为明为dics的vector容器创建迭代器
```

通用方法

- *：获取其中的值
- ++：迭代器移动一位
- ==：是否相等
- 1=：是否不同

## 排序

全排序：若!a<b&&!a>b则a==b

完整弱排序：可能完全相同，可能只在某方面相同

## 序列型容器

方法：

- front：无参数，返回第一个元素 》vector、list、deque
- back：无参数，返回最后一个元素 》vector、list、deque
- push_front：一个参数，插到前面 》list、deque
- push_back：元素添加到末尾》vector、list、deque
- pop_front：删掉第一个 》list、deque
- pop_back：删掉最后一个》vector、list、deque
- at：参数一个下标，返回元素 》vector、deque

通用：

- insert：迭代器+元素，元素插在迭代器前；迭代器+整数n+元素，将n个元素插在迭代器前；3个迭代器，将后面俩迭代器区间内的元素插入p前
- erase：迭代器，删除这个迭代器指向；2个迭代器，删除迭代器区间
- clear：清空，相当于erase(begin,end)

at与[]的区别：at会进行边界检查，错误会有out_of_range异常

vector不支持对front删除增加的原因：vector是数组，插入前面消耗太大，而其他两个都是链表，消耗小

## vector

vector是数组的一种类表示，它提供了自动内存管理功能，可以动态地改变vector对象的长度，并随着元素的添加和删除而增大和缩小。它提供了对元素的随机访问。在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间。

vector还是可反转容器（reversible container）概念的模型。这增加了两个类方法：rbegin( )和rend( )。返回的迭代器都是类级类型reverse_iterator。

## deque

deque模板类（在deque头文件中声明）表示双端队列（double-ended queue），通常被简称为deque。在STL中，其实现类似于vector容器，支持随机访问。主要区别在于，从deque对象的开始位置插入和删除元素的时间是固定的，而不像vector中那样是线性时间的。所以，如果多数操作发生在序列的起始和结尾处，则应考虑使用deque数据结构。

为实现在deque两端执行插入和删除操作的时间为固定的这一目的，deque对象的设计比vector对象更为复杂。vector容器执行这些操作时速度要快些。

## list

list模板类（在list头文件中声明）表示双向链表。

list和vector之间关键的区别在于，list在链表中任一位置进行插入和删除的时间都是固定的（vector模板提供了除结尾处外的线性时间的插入和删除，在结尾处，它提供了固定时间的插入和删除）。因此，vector强调的是通过随机访问进行快速访问，而list强调的是元素的快速插入和删除。

与vector相似，list也是可反转容器。与vector不同的是，list不支持数组表示法和随机访问。与矢量迭代器不同，从容器中插入或删除元素之后，链表迭代器指向元素将不变。

方法：

- merge：一个list参数，将两个排序过的链表有序合并
- remove：一个list参数，删除它有的元素
- sort：用<进行排序，不能用非成员的，因为链表并非是随机访问迭代器
- splice：位置+list参数，插入到位置前
- unique：将连续的相同元素压缩为1个
- remove_if：一个谓词函数参数，应用于每一个元素，返回true则删除

insert( )和splice( )之间的主要区别在于：insert( )将原始区间的副本插入到目标地址，而splice( )则将原始区间移到目标地址。

## forward_list

C++11新增了容器类forward_list，它实现了单链表。在这种链表中，每个节点都只链接到下一个节点，而没有链接到前一个节点。因此forward_list只需要正向迭代器，而不需要双向迭代器。因此，不同于vector和list，forward_list是不可反转的容器。相比于list，forward_list更简单、更紧凑，但功能也更少。

## queue

queue模板类（在头文件queue（以前为queue.h）中声明）是一个适配器类。queue模板让底层类（默认为deque）展示典型的队列接口。

queue模板的限制比deque更多。它不仅不允许随机访问队列元素，甚至不允许遍历队列。它把使用限制在定义队列的基本操作上，可以将元素添加到队尾、从队首删除元素、查看队首和队尾的值、检查元素数目和测试队列是否为空。

## priority_queue

priority_queue模板类（在queue头文件中声明）是另一个适配器类，它支持的操作与queue相同。两者之间的主要区别在于，在priority_queue中，最大的元素被移到队首（生活不总是公平的，队列也一样）。内部区别在于，默认的底层类是vector。

```c++
//构造函数
priority_queue<int> pq1;
priority_queue<int> pq2(greater<int>);//预定义函数对象
```

## stack

与queue相似，stack（在头文件stack——以前为stack.h——中声明）也是一个适配器类，它给底层类（默认情况下为vector）提供了典型的栈接口。

stack模板的限制比vector更多。它不仅不允许随机访问栈元素，甚至不允许遍历栈。它把使用限制在定义栈的基本操作上，即可以将压入推到栈顶、从栈顶弹出元素、查看栈顶的值、检查元素数目和测试栈是否为空。

## array

并非STL容器，因为其长度是固定的。因此，array没有定义调整容器大小的操作，如push_back( )和insert( )，但定义了对它来说有意义的成员函数，如operator [] ()和at( )。可将很多标准STL算法用于array对象，如copy( )和for_each( )。

## 关联容器

关联容器将值与键关联在一起，并使用键来查找值。

关联容器的优点在于，它提供了对元素的快速访问。与序列相似，关联容器也允许插入新元素，但不能指定元素的插入位置。原因是关联容器通常有用于确定数据放置位置的算法，以便能够快速检索信息。

关联容器通常是使用某种树实现的。树是一种数据结构，其根节点链接到一个或两个节点，而这些节点又链接到一个或两个节点，从而形成分支结构。像链表一样，节点使得添加或删除数据项比较简单；但相对于链表，树的查找速度更快。

类型

- set
- multiset
- map
- multimap

## set

最简单的关联容器是set，其值类型与键相同，键是唯一的，这意味着集合中不会有多个相同的键。是可反转的。

```c++
//定义格式
set<string> A;
set<string,less<string> > A;//可以指定比较函数或对象
```

## multiset

multiset类似于set，只是可能有多个值的键相同。

## map

在map中，值与键的类型不同，键是唯一的，每个键只对应一个值。阔以用数组的方式来访问和存储与键相关联的值。

## multimap

multimap与map相似，只是一个键可以与多个值相关联。

multimap也是可反转的、经过排序的关联容器，但键和值的类型不同，且同一个键可能与多个值相关联。

底层使用pair来将两个值存储到一个对象中，用first与second访问

```c++
//定义样式
multimap<int,string> codes;
multimap<int,string,less<string> > codes;
//元素单位
pair<const int ,string> item(123,"qwe");
//插入,按键顺序排，不需要指出插入位置
codes.insert(item);
//也可匿名插入
codes.insert(pair<const int ,string>(123,"qwe"));
```

成员函数

- equal_range：键为参数，找出键的所有范围，返回一个pair，该pair由前后迭代器组成，通过first与second阔以访问
- count：键为参数，统计该键的个数

## 无序关联容器

与关联容器一样，无序关联容器也将值与键关联起来，并使用键来查找值。但底层的差别在于，关联容器是基于树结构的，而无序关联容器是基于数据结构哈希表的，这旨在提高添加和删除元素的速度以及提高查找算法的效率。

- unordered_set
- unordered_multiset
- unordered_map
- unordered_multimap

## 函数对象

也叫函数符，函数符是可以以函数方式与( )结合使用的任意对象。

包括：

- 函数名
- 指向函数的指针
- 重载了( )运算符的类对象（即定义了函数operator( )( )的类）。

```c++
//实例，重载()
//成员函数重载
double operator()(double x){
    return 1+x;
}
//使用
demo f1;
if(1.1);//像函数一样使用对象
```

函数符类型：

- 生成器：不用参数就能调用的函数符
- 一元函数：一个参数就能调用的函数符
- 二元函数：两个参数就能调用的函数符

谓词：

- 返回bool值的一元函数是谓词
- 返回bool值的二元函数是二元谓词

用处：当某个函数只能包含一个参数，但是又需要能用另外一些参数改变其他函数内的变量时，阔以使用函数符来用构造函数设置那些需要改变的变量，再重载()使得其对象能成为谓词。

预定义的函数符

- transform：接收4个参数，前2个是迭代器范围，第3是复制位置的迭代器，第4是函数符【1个参数】，被应用于每个元素，然后生成新元素；接收5个参数，前两个是函数符的第一个参数的区间，第3个是另一个参数的起始迭代器，第4个参数是存入的迭代器，第5个是函数符号【2个参数】，被应用于两个参数中。

## 自适应函数符和函数适配器

原因：它携带了标识参数类型和返回类型的typedef成员。这些成员分别是result_type、first_argument_type和second_argument_type，它们的作用是不言自明的。例如，plus<int>对象的返回类型被标识为plus<int>::result_type，这是int的typedef。

意义：函数适配器对象可以使用函数对象，并认为存在这些typedef成员。例如，接受一个自适应函数符参数的函数可以使用result_type成员来声明一个与函数的返回类型匹配的变量。

函数适配器：解决一元函数与二元函数相互转换的问题

```c++
//函数适配器
//将接受两个参数的函数符转换为接受1个参数的函数符
//方法1：既定义一个类，用构造函数来解决
//方法2：使用函数适配器binder1st或binder2nd
binder1st(f2,val) f1;//val阔以指定值,f2被适配为1元，仅当f2为一个自适应函数才可这样整
//函数调用时f1(x) 等价于 f2(val,x)
//方法3:使用适配器bind1st或bind2nd化简于transform组合
//实例
transform(g.begin(),g.end(),out,bind1st(multiplies<double>(),2.5));
//2.5被当作一个参数了
//binder2nd类与此类似，只是将常数赋给第二个参数，而不是第一个参数。它有一个名为bind2nd的助手函数，该函数的工作方式类似于bind1st。
```

## 模板类函数对象

头文件：functional或function.h

对于所有内置的算术运算符、关系运算符和逻辑运算符，STL都提供了等价的函数符。包括：

- plus<>：完成常规+

  ```c++
  plus<double> add;//定义add函数对象-包含了()重载
  add(1.1,1.2);
  ```

- minus<>：-

- multiplies<>：*

- divides<>：/

- modulus<>：%

- negate<>：-

- equal_to<>：==

- not_equal_to<>：!=

- greater<>：>

- less<>：<

- greater_equal<>：>=

- less_equal<>：<=

- logical_and<>：&&

- logical_or<>：|

- logical_not<>：!

## for_each

原型

```c++
template<class inputiterator,class function>
function for_each(inputiterator first,inputiterator last, function f);
```



## 基于范围的循环

```c++
for(double x: pp) //pp可以是容器也可以是数组
	...
 //for_each不能改变容器内容，加上一个引用这个就可以修改惹
```

## 泛型编程

面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。

泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。当然，模板使得能够按泛型定义函数或类，而STL通过通用算法更进了一步。

## 重载++

为区分++运算符的前缀版本和后缀版本，C++将operator++()作为前缀版本，将operator++（int）作为后缀版本；

## 迭代器存在的意义

模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。

使用容器类时，无需知道其迭代器是如何实现的，也无需知道超尾是如何实现的，而只需知道它有迭代器，其begin( )返回一个指向第一个元素的迭代器，end( )返回一个指向超尾位置的迭代器即可。0

## STL算法

其内置的方法都是算法，总体都使用迭代器来标识要处理的数据区间和结果的放置位置。有些函数还接受一个函数对象参数，并使用它来处理数据。

对于算法函数设计，有两个主要的通用部分。首先，它们都使用模板来提供泛型；其次，它们都使用迭代器来提供访问容器中数据的通用表示。不同类型值阔以放在各种数据结构中，且不同容器内容于排序顺序相同时，也阔以说他们是相等的，当然也能相互转换。

算法库非类方法1-操作类型：

- 非修改式序列操作:algorithm》对区间中的每个元素进行操作。这些操作不修改容器的内容。find( )和for_each( )就属于这一类。
- 修改式序列操作:algorithm》对区间中的每个元素进行操作。然而，顾名思义，它们可以修改容器的内容。可以修改值，也可以修改值的排列顺序。transform( )、random_shuffle( )和copy( )属于这一类。
- 排序和相关操作:algorithm》包括多个排序函数（包括sort( )）和其他各种函数，包括集合操作。
- 通用数字运算:numeric》将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。vector是最有可能使用这些操作的容器。

算法库分类方法2-结果存放位置：

- 就地存放：结果存放在原始位置上，sort、
- 创建拷贝：结果发送到另一个位置，copy、
- 两面派：两种模式都有，复制版本的名称通常以_copy结尾。transform、replace
- 变体：根据将函数应用于容器元素得到的结果来执行操作，函数名称以_if结尾，如replace_if

算法的通用特征：原型使用模板参数名称来表示参数模型的概念。区间参数必须是输入迭代器或更高级别的迭代器，而指示结果存储位置的迭代器必须是输出迭代器或更高级别的迭代器。

虽然文档可指出迭代器或函数符需求，但编译器不会对此进行检查。如果您使用了错误的迭代器，则编译器试图实例化模板时，将显示大量的错误消息。

## STL函数和方法

选择：通常方法是更好的选择。首先，它更适合于特定的容器；其次，作为成员函数，它可以使用模板类的内存管理工具，从而在需要时调整容器的长度。

```c++
//方法更好的举例
list<int> la;
la.remove(4);//删除之后链表会自动调整大小
remove(la.begin(),la.end(),4);//删除之后不能调整大小，任然存在原本size的元素个数，删除时采用值前移战术，end指向的节点不变，但是阔以通过迭代器来修改容器的长度
```

方法

- tolower：一个整型参数，转换为小写
- count：三个参数，两个迭代器表示区间，一个键，统计键的出席那次数

STL算法都是内联的

## 其他的一些库

头文件：

- complex：为复数提供类模板complex，包含用于float、long和long double的具体化。这个类提供了标准的复数运算及能够处理复数的标准函数。
- random：提供了更多的随机数功能。
- valarray：用于表示数值数组，支持各种数值数组操作

## vector/valarray/array

- vector模板类是一个容器类和算法系统的一部分，它支持面向容器的操作，如排序、插入、重新排列、搜索、将数据转移到其他容器中等。
- valarray类模板是面向数值计算的，不是STL的一部分。它没有push_back( )和insert( )方法，但为很多数学运算提供了一个简单、直观的接口。可以用resize调整大小，另外俩可以自动调整。因为没有begin与end做支撑所以不能直接用迭代器，但是可以用取地址来解决。
- array模板类是为替代内置数组而设计的，它通过提供更好、更安全的接口，让数组更紧凑，效率更高。Array表示长度固定的数组，因此不支持push_back( )和insert( )，但提供了多个STL方法，包括begin( )、end( )、rbegin( )和rend( )，这使得很容易将STL算法用于array对象。

模板类是容器，类模板生成的是对象，两者不同。

```c++
//声明方法
vector<int> 
valarray<int> va;//可以用来对应元素的加减乘除，与矩阵运算相似
array<int,size>
//apply用于valarray
va.apply(log);  //生成一个新的对象
log(va);  //每个元素都用log函数求对数
```

用法：用vector收集数据，再复制到valarray中执行数学运算。

## slice类

slice类对象可用作数组索引，在这种情况下，它表的不是一个值而是一组值。slice对象被初始化为三个整数值：起始索引、索引数和跨距。起始索引是第一个被选中的元素的索引，索引数指出要选择多少个元素，跨距表示元素之间的间隔。

放在[]中，可以返回下标中指定的所有的值

## initializer_list

本质上就是花括号，{}，其类型就是initializer_list,可以当容器来使用，可以在初始化对象，变量，数组，结构体时调用。list内部所有元素的类型要相同。可以用来充当函数的参数，定义方式如下：

```c++
//需要指定类型
//头文件必须要包含initializer_list
//这个模板类包含成员函数begin( )和end( )，您可使用这些函数来访问列表元素。它还包含成员函数size( )，该函数返回元素数。
void demo(std::initializer_list<int> li);
```

