## unix常规

默认shell版本：bash-》操作应用程序与kernel沟通

命令的别名：alias

## 快捷键

tab：文件名补全/命令补全/2次文件提示
ctrl+c：中断当前执行程序
ctrl+d：键盘输入EOF/可以取代exit

## 运行等级

切换等级：init {1-7}
0：关机
3：纯文本
5：图形接口模式ll
6：重启

## 启动问题

文件系统错误
	错误原因:
		1、断电或不正常关机，导致文件系统错误
		2、硬盘使用率过高或环境不良，硬件损坏
	解决方法：
		软件错误可以用fsck来修复
		1、根目录没坏，修复坏掉的磁盘
		2、根目录坏了，拔掉磁盘，修复第一个磁盘所sdb1
	预防：
		1、妥善保养磁盘
		2、划分不同分区，坏掉的地方不会影响到别的磁区
root密码忘记
	解决方法：
		开机时进入，单人维护模式修改

## 文本编辑常用按键

- 按q 退出查询
- 按空格 翻页
- /word或?word 文档中的查询功能 大小写n分别控制上下
- 按空格 下一行
- 更多：http://cn.linux.vbird.org/linux_basic/0310vi.php#vi_vim

## 命令的类型

l1、输入后直接显示结果，后返回到命令提示符等待下一个命令
2、输入后进入该命令的环境，结束命令才回到命令提示符

## 命令的格式

commend [-option] paramenter1 paramenter2 pa...
	-option 为缩写
	--option 为全名
	+option 格式

在命令前加上反斜线可以**忽略alias选项**

多个**连续**的不相关命令可以用；隔开，相关的可以用&&或||，从左向右运行

**太长**用\ [Enter] 来换行

**管线命令**用|隔开，信息一个传一个，只传standard output，常用命令有：cut, grep, sort, wc, uniq, tee, tr, col, join, paste, expand, split, xargs 等。

**信息摘要**用cut或grep进行摘要

## 命令/文件的用法说明

1、man 指令名
	命令等级说明：man man
		1：shell中可用的
		3：c库
		5：配置文件或文件格式
		8：管理员命令
	查询顺序：
		name，概述
		description，详述
		example，案例			
		options，参数
		see also，其他查询渠道
		file，相关文件
2、info 指令名
	条件：必须在/usr/share/info/中有.info的说明文档，非info的说明文档为man page
3、/usr/share/doc目录中的文件

## 文本编辑器

- naon
- vi：所有的 Unix Like 系统都会内建 vi 文书编辑器
- vim：带颜色，方便打代码

## vi

```
builtin
```

模式：

- 一般模式：阅读
- 编辑模式：编辑，输入任意字符进入
- 指令列命令模式：执行某些指令

## 关机

1、先使用sync将缓存在内存中的数据写入磁盘中[shutdown/reboot/halt均在关机前呼叫了]
2、shutdown/reboot/halt/poweroff:呼叫的函数库都差不多

## 命令

- sync：数据同步被写入磁盘
- shutdown：关机
- reboot：重启
- halt：关机
- exit：离开系统
- init：切换系统运行模式
- mount：磁盘挂载[启动自动挂载配置文件/etc/fstab]
- unmount：装置文件卸载
- fdisk：对磁盘进行各种操作，分割、删除、显示等，不能处理2T以上的
- parted：也是对磁盘进行分割等操作，限制比较小
- partprobe：更新partition table
- mkfs【make filesystem】：磁盘格式化
- mke2fs：精细化的此磁盘格式化
- e2label：修改文件系统标头
- mknod：配置设备/FIFO文件,major与minor表示
- fsck【filesystem check】：检查文件系统是否混乱，可能会造成错误
- badblocks：检查是否有坏轨
- df：根据superblock，列出文件系统的整体磁盘使用量，不是内存哦
- du：推估当前目录中的文件占磁盘容量，会直接到文件系统内去搜寻所有的文件数据
- dump2fs：查看文件系统的信息
- tune2fs：可以查看superblock，也可转换文件系统ext2->3
- hdparm：调整硬盘参数或测试效能
- mkswap：格式化为swap格式
- swapon：启动swap设备文件
- swapoff：关闭swap设备文件
- 查看时间:date：
  	+%Y/%m/%d格式化日期
    	+%h:%M 格式化时间
- cal：查看日历
- bc：计算器
- ls：查看文件属性
- ll：是ls -l别名
- alias：查看/设置别名
- unalias：取消别名
- who：查看在线用户
- locale：查看支持的语系
- env：查看环境变量
- set：查看所有的变量/配置输入输出环境
- export：设置/显示自定义变量为环境变量
- declare：声明变量的类型或环境/自定义
- su：切换用户
- lp[line print]开头：打印相关命令 *
- echo ：显示各种
- last：显示用户登陆时间
- history：查看历史命令记录[~/.bash_history]大小为HISTFILESIZE
- ！：!number运行第n条命令，!!运行上一个命令，!command运行以command开头的命令
- ifconfig：查看系统ip
- 改变文件属性和权限
  		    chgrp：改变所属群组
    	chown：改变文件拥有者与组
    	chmod：改变文件权限，SUID, SGID, SBIT等等的特性
- cp：复制
- touch：创建文件/修改文件时间
- rm：删除文件
- cat：读取文件/创建文件并输入内容
- mv：移动文件/更名
- rename：更名
- ln：创建实体或符号链接
- 查看系统的信息
  	     uname
    	lsb_release
- cd：变换目录
- pwd：显示目前的目录 - Print Working Directory
- mkdir：创建一个新的目录
- rmdir：删除一个空的目录
- basename：档名
- dirname：目录名 
- cat  由第一行开始显示文件内容
- tac  从最后一行开始显示，可以看出 tac 是 cat 的倒著写！
- nl  显示文件的时候，顺道输出行号！
- more 一页一页的显示文件内容 --呼叫了less
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行
- od    以二进位的方式读取文件内容！
- umask：查看/设置当前使用者创建文件/目录的默认权限
- chattr (修改与配置文件隐藏属性)
- lsattr (显示文件隐藏属性)getfacl：
- file：观察文件类型
- which：根据PATH查找可运行的文档的位置
- type：与 which相同，但是可以找到bash内建的命令
- whereis：利用数据库文件来寻找特定文件的位置
- locate：利用数据库文件[/var/lib/mlocate ]来寻找相关文件名的文件位置
- find：从磁盘中搜索各种文件，搜索的功能丰富如所有者、时间、名字、权限
- useradd：新建用户
- userdel：删除账号
- passwd：修改密码以及管理账号
- change：修改用户的shadow文件内的口令参数
- usermod：修改用户的相关信息
- finger/id：查看用户信息
- groupadd：建立群组
- groups：查看有效群组和支持群组
- newgrp：切换有效群组
- gpasswd：群组管理员功能
- groupmod：修改群组的相关信息
- groupdel：删除群组
- getfacl：取得某个文件/目录的 ACL 配置项目；
- setfacl：配置某个目录/文件的 ACL 规范。
- gzip：压缩命令 - 可以解开gz/z，默认压缩后原文件不在了
- zcat ：可以读取纯文字档被压缩后的压缩档
- bzip2：比gzip更好的压缩比 - bz2
- bzcat：可以读取纯文字档被压缩后的压缩档
- tar：可以将多个目录或文件打包成一个大文件，压缩过的为tarball否则为tarfile
- dump：备份
- restore：恢复备份
- mkisofs：创建映像文档
- cdrecord：映像文档烧录
- dd：可以直接读取装置，可用来创建空文件[/dev/zero]或拿来备份
- cpio：可以备份任何东西并还原
- unix2dos：linux格式转化为dos
- dos2unix：dos格式转化为linux
- iconv：转换文件格式
- read：读取键盘中的输入
- ulimit：限制用户某些系统资源
- source或.：读取/更新配置文件到当前shell
- stty：设置终端机环境，如热键等
- cut：对行进行分割摘出
- grep：分析行，若为所需取出该行，用正则
- egrep：可以使用延伸的正则表达式
- sed：对input或文件进行增删改查
- awk：input或文件的数据处理工具，根据空格或者tab进行分栏
- printf：格式化输出
- sort：对数据进行排序
- uniq：只保留一个，并且可以统计数量
- wc：计算信息的整体数据
- tr：文字替换或删除
- col：消除特殊字符所带来的阅读不适
- join：将两个文件中，有相同字段的对应行链接在一起
- paste：将两个文件按行拼在一起
- expand：将tab转化为空格
- split：文件分割为小文件，用stdin/stdout可以再拼接回一个
- xargs：参数代换，将input中的内容用作后面命令的参数
- diff：以行为单位，对比两个文件的区别
- cmp：以位组bytes为单位，找到两个文件的不同
- patch：用diff出的补丁patch用来升级或者还原
- pr：文件打印的各种复杂设置

## 命令的运行顺序

1. 以相对/绝对路径运行命令，例如『 /bin/ls 』或『 ./ls 』；
2. 由 alias 找到该命令来运行；
3. 由 bash 内建的 (builtin) 命令来运行；
4. 透过 $PATH 这个变量的顺序搜寻到的第一个命令来运行。

## 特殊目录

```
.         代表此层目录
..        代表上一层目录
-         代表前一个工作目录
~         代表『目前使用者身份』所在的家目录
~account  代表 account 这个使用者的家目录(account是个帐号名称)
```

## 文件权限

1. 特殊权限
2. 使用者
3. 群组
4. 其他人
5. ACL权限 + 号
6. root【拥有所有权限】

**设置理由**

提供数据保护或者限定的数据共享

**权限的用途**

- 权限之于文件：能否对内容的处理，以及执行文件
- 权限之于目录：能否对目录内容的处理，以及切换进目录
- 对于目录：rx通常一起存在，否则无法读取

**默认权限**

- root默认umask：022，删w
- 一般用户默认umask：002

**特殊权限**

- SUID：s出现在拥有者x位置上，只对二进制文件有效，用户执行时临时赋予拥有者权限
- SGID：s出现在群组x位置上，对二进制文件或目录有效，有rx权，执行时获得该群组的支持
- SBIT：t出现在other上，只针对目录有效，对目录有wx权，但在删除时只有拥有者和root可

## 文件属性

属性首位

- 一般文件regular：-
- 目录文件directory：d
- 连结文档link：l
- 区块设备block：b
- 字符设备charactrer：c
- 数据接口文件sockets：s
- 数据输送文件pipe：p

文件拓展名【只用来了解用途】：

- .sh：脚本或批处理文件
- Z/tar/tar.gz/zip/tgz：压缩文件
- html/php：网页文件

文件头：

- .：表示隐藏文档

时间

- atime：访问时间
- ctime：状态修改时间
- mtime：内容修改时间

## FHS目录配置标准

- /：根目录，开机系统相关
- /usr(unix software resource)：软件有关
- /var：系统运行过程有关

## 开机文件

- /etc：配置文件
- /bin：重要执行档利用内存虚拟出来的磁盘空间
- /dev：所需要的装置文件
- /lib：执行档所需的函式库与核心所需的模块
- /sbin：重要的系统执行文件

应该和根目录放在同一个分割槽

## 身份信息存储位置或者``也可

1. 所有账号/ 使用者/root：etc/passwd
2. 个人密码：etc/shadow
3. 组名：etc/group

## 文件系统

linux使用**Ext2/Ext3**文件系统，Ext2是一个索引式文件系统，Ext3是一个日志式文件系统

所有文件会用一个**文件数据库**来保存，默认每天更新一次，可以主动更新，也可以修改配置文件修改更新时间[/etc/updatedb.conf ]

一个可被挂载的数据为一个**文件系统**，传统磁盘与文件系统中，一个分割槽就是一个文件系统，新技术通过LVM和磁盘阵列，导致一个分割槽可以多个，多个分割槽可以化为1个。

**文件数据**：

- 文件实际内容
- 文件权限、文件属性

**数据区块**：

- inode：存放文件的属性和权限，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码
- data block：存放文件的实际数据，若文件太大时，会占用多个 block。
- superblock：存放文件系统的整体信息，包括inode/block的总量、使用量、剩余量， 	以及文件系统的格式与相关信息等

**碎片整理**：需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差所致。这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起，这样数据的读取会比较容易啊！

**目录数据存储形式**：inode记录目录信息，block记录内含文件的inode信息

**运行方式**：采用异步处理的方式对文件进行存取，定时更新脏数据，可以用sync强制写回

**挂载点**：目录即是挂载点，将文件系统和目录树结合的方法为挂载，文件系统，一个挂载点对应一个文件系统，顶层目录的inode为2,文件系统为硬件，目录为软件

**管理**：用VFS【virtual filsystem switch】来管理所有的文件系统

## Ext2区块群组

为了方便管理，格式化的时候以区块群组的方式来划分，每个区块群组都有独立的  	inode/block/superblock 系统，全部的block group组成一个文件系统。内容如下：

**data block**的限制：

- 原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)；
- 每个 block 内最多只能够放置一个文件的数据；
- 承上，如果文件大于 block 的大小，则一个文件会占用多个 block 数量，block过小inode要记录很多；
- 承上，若文件小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)，block过大要浪费很多。

**inode**使用：

- 每个 inode 大小均固定为 128 bytes，可以用多级block间接来记录大量的block
- 每个文件都仅会占用一个 inode 而已；
- 承上，因此文件系统能够创建的文件数量与 inode 的数量有关；
- 系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际读取 block 的内容。

**Superblock**

- block 与 inode 的总量；
- 未使用与已使用的 inode / block 数量；
- block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)；
- filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；
- 一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。
- 每个block group都可能有一个superblock，第一个为主，其他都备份。

**Filesystem Description**：描述每个 block group 的开始与结束的 block 号码

**block bitmap**：记录block是否为空

**inode bitmap** ：记录inode是否为空

## Ext2文件操作过程

**文件/目录读取**：

1. 读取根的inode获取权限以及block位置，若有权限继续
2. 根据目录的block记录的inode继续读取，不断重复直到找到

**文件/目录建立**：

1. 先确定用户对于欲新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增；
2. 根据 inode bitmap 找到没或者``也可有使用的 inode 号码，并将新文件的权限/属性写入；
3. 根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且升级 inode 的 block 指向数据；
4. 将刚刚写入的 inode 与 block 数据同步升级 inode bitmap 与 block bitmap，并升级 superblock 的内容。

## Ext3日志式文件系统

意义：解决文件更新到一般系统卡住，需要检查整个filesystem一致性很慢的问题。

做法：在我们的 filesystem 当中规划出一个区块，该区块专门在记录写入或修订文件时的步骤

1. 预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；
2. 实际写入：开始写入文件的权限与数据；开始升级 metadata 的数据；
3. 结束：完成数据与 metadata 的升级后，在日志记录区块当中完成该文件的纪录。

优点：

- 速度：日志让读取头移动更有效
- 数据完整性：可以避免数据损毁
- 可利用性：能快速从系统终止到恢复原样
- 易转换性：ext2可以方便的转换为ext3

## 命令与文件的关系

一、让使用者能进入某目录成为『可工作目录』的基本权限为何：

- 可使用的命令：例如 cd 等变换工作目录的命令；
- 目录所需权限：使用者对这个目录至少需要具有 x 的权限
- 额外需求：如果使用者想要在这个目录内利用 ls 查阅档名，则使用者对此目录还需要 r 的权限。

二、使用者在某个目录内读取一个文件的基本权限为何？

- 可使用的命令：例如本章谈到的 cat, more, less等等
- 目录所需权限：使用者对这个目录至少需要具有 x 权限；
- 文件所需权限：使用者对文件至少需要具有 r 的权限才行！

三、让使用者可以修改一个文件的基本权限为何？

- 可使用的命令：例如 [nano](http://cn.linux.vbird.org/linux_basic/0160startlinux.php#nano) 或未来要介绍的 [vi](http://cn.linux.vbird.org/linux_basic/0310vi.php) 编辑器等；
- 目录所需权限：使用者在该文件所在的目录至少要有 x 权限；
- 文件所需权限：使用者对该文件至少要有 r, w 权限

四、让一个使用者可以创建一个文件的基本权限为何？

- 目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w 啦！

五、让使用者进入某目录并运行该目录下的某个命令之基本权限为何？

- 目录所需权限：使用者在该目录至少要有 x 的权限；
- 文件所需权限：使用者在该文件至少需要有 x 的权限

## 磁盘的第一个扇区

第一个扇区最重要，里面有：(1)主要启动区(Master boot record, MBR)及分割表(partition table)， 	其中 MBR 占有 446 bytes，而 partition table 则占有 64 bytes。因此分割表最多只能纪录4个分割槽以及59个逻辑分割槽。

## 虚拟磁盘

/dev/shm/：利用内存虚拟出来的磁盘空间

## 文件的链接

- 实体链接在这个 bash 底下所下达的任何命令都是由这个 bash 所衍生出来的，那些被下达的命令就被称为子程序了hard link：透过文件系统的 inode 连结来产生新档名，而不是产生新文件
- 符号链接/快捷链接Symbolic Link：创建一个独立的文件，而这个cd 桌面文件会让数据的读取指向他  	link 的那个文件的档名

 hard link 只是在某个目录下的 block多写入一个关连数据而已，既不会添加 inode 也不会耗用 block 数量，但是不能跨 Filesystem，不能 link 目录，因为链接目录要将所有档名hardlink，比较复杂。

**由** Symbolic link 所创建的文件为一个独立的新的文件，所以会占用掉 inode 与 block

新目录链接数量：新的目录的 link 数为 2 [/.和/]，而上一级目录的 link 数则会添加 1 [/..]

## 添加磁盘

1. 用fdisk对磁盘进行分割，以创建可用的 partition ，再用partprobe进行更新；
2. 对该 partition 进行格式化( format )，以创建系统可用的 filesystem；
3. 若想要仔细一点，则可对刚刚创建好的 filesystem 进行检验；
4. 在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来；

## 单人维护模式

/是read only状态，无法修改，可以通过mount重新挂载

## loop装置挂载

loop device设备是通过影射操作系统上的正常的文件，将文件虚拟的一个虚拟磁盘块设备。

可以在原本的分割槽在不更动原有的环境下制作出你想要的分割槽。

步骤：

1. 用dd创建一个大型空文件
2. 用mkfs格式化
3. 用mount挂载

## 内存置换空间swap

​	swap 的功能就是在应付物理内存不足的情况下所造成的内存延伸记录的功能。

构建swap的方法：

1. 实体分割槽
2. 虚拟内存文件

实体分割步骤：

1. 分割：先使用 fdisk 在你的磁盘中分割出一个分割槽给系统作为 swap 。由于 Linux 的 fdisk  	默认会将分割槽的 ID 配置为 Linux 的文件系统，所以你可能还得要配置一下 system ID 就是了。
2. 格式化：利用创建 swap 格式的『mkswap echo $变量装置文件名』就能够格式化该分割槽成为 swap 格式啰
3. 使用：最后将该 swap 装置启动，方法为：『swapon 装置文件名』。
4. 观察：最终透过 free 这个命令来观察一下内存的用量吧！

虚拟内存文件步骤：

1. 并不会影响用dd新增一个空文件
2. 用mkswap格式化这个文件
3. 用swapon启动文件
4. 使用后可以通过swapoff关闭

如果你的主机支持电源管理模式， 	也就是说，你的 Linux 主机系统可以进入『休眠』模式的话，那么， 	运行当中的程序状态则会被纪录到 swap 去，以作为『唤醒』主机的状态依据！

swap限制：最多32个，最大64g【最大寻址】

## boot sector 与  superblock 的关系

boot sector：引导扇内区，通常在第一个扇区

当block==1024bytes时，两者分开block存放

当block>1024bytes时，两者放在同一个block

## 空间浪费

superblock/inode/data block等中介数据都会占用额外的磁盘容量

## bash

默认的shell

**优点**：

- 命令编修能力 (history)：所有指令都存在~./bash_history中
- 命令与文件补全功能([tab] 按键的好处)
- 命令别名配置功能 (alias)：可以自主设置
- 工作控制、前景背景控制： (jo内b control, foreground, background)
- 程序化脚本： (shell scripts)
- 通配符： (Wildcard)

## 变量

某一个特定字符串代表不固定的内容

**使用**：

- 可以用echo来查看系统的变量：echo $变量 或echo ${变量}
- script中，用$引用变量，
- 配置变量，直接用=

**类型**：

- 环境变量-大写
- 自定义变量内内

**变量配置守则**：

1. 变量与变量内容以一个等号『=』来连结，如下所示： 		
   『myname=VBird』
2. 等号两边不能直接接空格符，如下所示为错误： 		
   『myname = VBird』或『myname=VBird Tsai』
3. 变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误： 		
   『2myname=VBird』
4. 变量内容若有空格符可使用双引号『"』或单引号『'』将变量内容结合起来，但 		
   - 双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示：
      		『var="lang is $LANG"』则『echo $var』可得『lang is en_US』
   - 单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示：
      		『var='lang is $LANG'』则『echo $var』可得『lang is $LANG』
5. 可用跳脱字符『 \ 』将特殊符号(如 [Enter], $, \, 空格符,  		'等)变成一般字符；
6. 在一串命令中，还需要藉由其他的命令提供的信息，可以使用反单引号『`命令`』或 		『$(命令)』。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号！ 		例如想要取得核心版本的配置：
   『version=$(uname -r)』再『echo  		$version』可得『2.6.18-128.el5』
7. 若该变量为扩增变量内容时，则可用 "$变量名称" 或 ${变量} 累加内容，如下所示：
    		『PATH="$PATH":/home/bin』
8. 若该变量需要在其他子程序运行，则需要以 export 来使变量变成环境变量：
    		『export PATH』
9. 通常大写字符为系统默认变量，自行配置变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) ；
10. 取消变量的方法为使用 unset ：『unset  		变量名称』例如取消 myname 的配置：
     		『unset myname』

**bash的子程序：**在bash中执行的所有命令都是子程序，子程序仅会继承父程序的环境变量， 	子程序不会继承父程序的自定义变量

**删除部分显示**：echo ${变量#..} ，从前开始删 #右边是要删掉的最短匹配   ##表示删除最长匹配，从后开始删用的% 

**替换部分显示**：echo ${变量 /x/y} or  echo ${变量 //x/y} 一条是替换第一个x，两条是替换所有

命令别名与变量有什么不同呢？命令别名是『新创一个新的命令， 	你可以直接下达该命令』的，至于变量则需要使用类似『 echo 』命令才能够呼叫出变量的内容

## bash环境配置文件

- /etc/motd：登陆后的提示信息
- /etc/issue：登陆画面显示信息
- /etc/sysconfig/i18n：决定使用语系
- /etc/man.config：man去哪里找
- /etc/shells：查看支持哪些壳
- ~/.bash_history：记录命令历史
- ~/.bash_logout：注销后系统的行为
- /dev/null：垃圾信息收集装置，不要的都可以输入到这

login shell[由完整登陆流程获得的shell]读取的配置文件

- /etc/profile：系统整体的配置，每个使用者登陆取得 bash 时一定会读取的配置文件
- ~/.bash_profile：使用者的个人配置文件，下面这三个只会读取一个
- ~/.bash_login
- ~/.profile

non-login shell[获得bash接口的方法不需要重复登陆的]读取的配置文件

- ~/.bashrc

## 数据流重导向

1. 标准输入　　(stdin) ：代码为 0 ，使用 < 或 << ；单箭头为覆盖，双为累加
2. 标准输出　　(stdout)：代码为 1 ，使用 > 或 >> ；默认
3. 标准错误输出(stderr)：代码为 2 ，使用 2> 或 2>> ；
4. 两个信息写入一个，可以用2>&1来组合才不会混乱
5. 双向重导向tee：不光输出到屏幕上，还输出到某个tee到的目标文件中

当需要stdin/stdout却没有文件时，可以用-来代替

## 文件的格式化与处理

格式化打印：printf

- %s：字符
- %i：数字
- %f：浮点数

## 用户标识

系统利用 UID 与 GID 认识每个用户

账号记录：/etc/passwd

组名记录：/etc/group and /etc/gshadow

密码记录：/etc/shadow

**登陆过程**：

1. wd 里面是否有你输入的账号？如果没有则跳出，如果有的话则将该账号对应的 	UID 与 GID (在 /etc/group 中) 读出来，另外，该账号的家目录与 shell 配置也一并读出；
2. 再来则是核对口令表啦！这时 Linux 会进入 /etc/shadow 里面找出对应的账号与  	UID，然后核对一下你刚刚输入的口令与里头的口令是否相符？
3. 如果一切都 OK 的话，就进入 Shell 控管的阶段啰！

UID：0是root、1～500非登陆的系统用户、其余一般用户

**创建用户过程**：

1. useradd创建一个用户，此时shadow第二栏中为！，为封锁状态
2. 用passwd配置口令
3. 若没有/home/user，需要root来复制/etc/skel 创建一个目录给用户

## ACL细部权限规划

ACL 是 Access Control List 的缩写，主要的目的是在提供传统的  	owner,group,others 的 read,write,execute 权限之外的细部权限配置。ACL  	可以针对单一使用者，单一文件或目录来进行

ext3默认支持acl，不支持可以用mount调整或者配置/etc/fstab

主要使用getfacl与setfacl对于某个文件或目录进行配置和查询